// Code generated by protoc-gen-go. DO NOT EDIT.
// source: messages.proto

package kkProto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// *
// Mapping between KeepKey wire identifier (uint) and a protobuf message
type MessageType int32

const (
	MessageType_MessageType_Initialize          MessageType = 0
	MessageType_MessageType_Ping                MessageType = 1
	MessageType_MessageType_Success             MessageType = 2
	MessageType_MessageType_Failure             MessageType = 3
	MessageType_MessageType_ChangePin           MessageType = 4
	MessageType_MessageType_WipeDevice          MessageType = 5
	MessageType_MessageType_FirmwareErase       MessageType = 6
	MessageType_MessageType_FirmwareUpload      MessageType = 7
	MessageType_MessageType_GetEntropy          MessageType = 9
	MessageType_MessageType_Entropy             MessageType = 10
	MessageType_MessageType_GetPublicKey        MessageType = 11
	MessageType_MessageType_PublicKey           MessageType = 12
	MessageType_MessageType_LoadDevice          MessageType = 13
	MessageType_MessageType_ResetDevice         MessageType = 14
	MessageType_MessageType_SignTx              MessageType = 15
	MessageType_MessageType_SimpleSignTx        MessageType = 16
	MessageType_MessageType_Features            MessageType = 17
	MessageType_MessageType_PinMatrixRequest    MessageType = 18
	MessageType_MessageType_PinMatrixAck        MessageType = 19
	MessageType_MessageType_Cancel              MessageType = 20
	MessageType_MessageType_TxRequest           MessageType = 21
	MessageType_MessageType_TxAck               MessageType = 22
	MessageType_MessageType_CipherKeyValue      MessageType = 23
	MessageType_MessageType_ClearSession        MessageType = 24
	MessageType_MessageType_ApplySettings       MessageType = 25
	MessageType_MessageType_ButtonRequest       MessageType = 26
	MessageType_MessageType_ButtonAck           MessageType = 27
	MessageType_MessageType_GetAddress          MessageType = 29
	MessageType_MessageType_Address             MessageType = 30
	MessageType_MessageType_EntropyRequest      MessageType = 35
	MessageType_MessageType_EntropyAck          MessageType = 36
	MessageType_MessageType_SignMessage         MessageType = 38
	MessageType_MessageType_VerifyMessage       MessageType = 39
	MessageType_MessageType_MessageSignature    MessageType = 40
	MessageType_MessageType_PassphraseRequest   MessageType = 41
	MessageType_MessageType_PassphraseAck       MessageType = 42
	MessageType_MessageType_EstimateTxSize      MessageType = 43
	MessageType_MessageType_TxSize              MessageType = 44
	MessageType_MessageType_RecoveryDevice      MessageType = 45
	MessageType_MessageType_WordRequest         MessageType = 46
	MessageType_MessageType_WordAck             MessageType = 47
	MessageType_MessageType_CipheredKeyValue    MessageType = 48
	MessageType_MessageType_EncryptMessage      MessageType = 49
	MessageType_MessageType_EncryptedMessage    MessageType = 50
	MessageType_MessageType_DecryptMessage      MessageType = 51
	MessageType_MessageType_DecryptedMessage    MessageType = 52
	MessageType_MessageType_SignIdentity        MessageType = 53
	MessageType_MessageType_SignedIdentity      MessageType = 54
	MessageType_MessageType_GetFeatures         MessageType = 55
	MessageType_MessageType_EthereumGetAddress  MessageType = 56
	MessageType_MessageType_EthereumAddress     MessageType = 57
	MessageType_MessageType_EthereumSignTx      MessageType = 58
	MessageType_MessageType_EthereumTxRequest   MessageType = 59
	MessageType_MessageType_EthereumTxAck       MessageType = 60
	MessageType_MessageType_CharacterRequest    MessageType = 80
	MessageType_MessageType_CharacterAck        MessageType = 81
	MessageType_MessageType_RawTxAck            MessageType = 82
	MessageType_MessageType_ApplyPolicies       MessageType = 83
	MessageType_MessageType_FlashHash           MessageType = 84
	MessageType_MessageType_FlashWrite          MessageType = 85
	MessageType_MessageType_FlashHashResponse   MessageType = 86
	MessageType_MessageType_FlashDump           MessageType = 87
	MessageType_MessageType_FlashDumpResponse   MessageType = 88
	MessageType_MessageType_DebugLinkDecision   MessageType = 100
	MessageType_MessageType_DebugLinkGetState   MessageType = 101
	MessageType_MessageType_DebugLinkState      MessageType = 102
	MessageType_MessageType_DebugLinkStop       MessageType = 103
	MessageType_MessageType_DebugLinkLog        MessageType = 104
	MessageType_MessageType_DebugLinkFillConfig MessageType = 105
)

var MessageType_name = map[int32]string{
	0:   "MessageType_Initialize",
	1:   "MessageType_Ping",
	2:   "MessageType_Success",
	3:   "MessageType_Failure",
	4:   "MessageType_ChangePin",
	5:   "MessageType_WipeDevice",
	6:   "MessageType_FirmwareErase",
	7:   "MessageType_FirmwareUpload",
	9:   "MessageType_GetEntropy",
	10:  "MessageType_Entropy",
	11:  "MessageType_GetPublicKey",
	12:  "MessageType_PublicKey",
	13:  "MessageType_LoadDevice",
	14:  "MessageType_ResetDevice",
	15:  "MessageType_SignTx",
	16:  "MessageType_SimpleSignTx",
	17:  "MessageType_Features",
	18:  "MessageType_PinMatrixRequest",
	19:  "MessageType_PinMatrixAck",
	20:  "MessageType_Cancel",
	21:  "MessageType_TxRequest",
	22:  "MessageType_TxAck",
	23:  "MessageType_CipherKeyValue",
	24:  "MessageType_ClearSession",
	25:  "MessageType_ApplySettings",
	26:  "MessageType_ButtonRequest",
	27:  "MessageType_ButtonAck",
	29:  "MessageType_GetAddress",
	30:  "MessageType_Address",
	35:  "MessageType_EntropyRequest",
	36:  "MessageType_EntropyAck",
	38:  "MessageType_SignMessage",
	39:  "MessageType_VerifyMessage",
	40:  "MessageType_MessageSignature",
	41:  "MessageType_PassphraseRequest",
	42:  "MessageType_PassphraseAck",
	43:  "MessageType_EstimateTxSize",
	44:  "MessageType_TxSize",
	45:  "MessageType_RecoveryDevice",
	46:  "MessageType_WordRequest",
	47:  "MessageType_WordAck",
	48:  "MessageType_CipheredKeyValue",
	49:  "MessageType_EncryptMessage",
	50:  "MessageType_EncryptedMessage",
	51:  "MessageType_DecryptMessage",
	52:  "MessageType_DecryptedMessage",
	53:  "MessageType_SignIdentity",
	54:  "MessageType_SignedIdentity",
	55:  "MessageType_GetFeatures",
	56:  "MessageType_EthereumGetAddress",
	57:  "MessageType_EthereumAddress",
	58:  "MessageType_EthereumSignTx",
	59:  "MessageType_EthereumTxRequest",
	60:  "MessageType_EthereumTxAck",
	80:  "MessageType_CharacterRequest",
	81:  "MessageType_CharacterAck",
	82:  "MessageType_RawTxAck",
	83:  "MessageType_ApplyPolicies",
	84:  "MessageType_FlashHash",
	85:  "MessageType_FlashWrite",
	86:  "MessageType_FlashHashResponse",
	87:  "MessageType_FlashDump",
	88:  "MessageType_FlashDumpResponse",
	100: "MessageType_DebugLinkDecision",
	101: "MessageType_DebugLinkGetState",
	102: "MessageType_DebugLinkState",
	103: "MessageType_DebugLinkStop",
	104: "MessageType_DebugLinkLog",
	105: "MessageType_DebugLinkFillConfig",
}
var MessageType_value = map[string]int32{
	"MessageType_Initialize":          0,
	"MessageType_Ping":                1,
	"MessageType_Success":             2,
	"MessageType_Failure":             3,
	"MessageType_ChangePin":           4,
	"MessageType_WipeDevice":          5,
	"MessageType_FirmwareErase":       6,
	"MessageType_FirmwareUpload":      7,
	"MessageType_GetEntropy":          9,
	"MessageType_Entropy":             10,
	"MessageType_GetPublicKey":        11,
	"MessageType_PublicKey":           12,
	"MessageType_LoadDevice":          13,
	"MessageType_ResetDevice":         14,
	"MessageType_SignTx":              15,
	"MessageType_SimpleSignTx":        16,
	"MessageType_Features":            17,
	"MessageType_PinMatrixRequest":    18,
	"MessageType_PinMatrixAck":        19,
	"MessageType_Cancel":              20,
	"MessageType_TxRequest":           21,
	"MessageType_TxAck":               22,
	"MessageType_CipherKeyValue":      23,
	"MessageType_ClearSession":        24,
	"MessageType_ApplySettings":       25,
	"MessageType_ButtonRequest":       26,
	"MessageType_ButtonAck":           27,
	"MessageType_GetAddress":          29,
	"MessageType_Address":             30,
	"MessageType_EntropyRequest":      35,
	"MessageType_EntropyAck":          36,
	"MessageType_SignMessage":         38,
	"MessageType_VerifyMessage":       39,
	"MessageType_MessageSignature":    40,
	"MessageType_PassphraseRequest":   41,
	"MessageType_PassphraseAck":       42,
	"MessageType_EstimateTxSize":      43,
	"MessageType_TxSize":              44,
	"MessageType_RecoveryDevice":      45,
	"MessageType_WordRequest":         46,
	"MessageType_WordAck":             47,
	"MessageType_CipheredKeyValue":    48,
	"MessageType_EncryptMessage":      49,
	"MessageType_EncryptedMessage":    50,
	"MessageType_DecryptMessage":      51,
	"MessageType_DecryptedMessage":    52,
	"MessageType_SignIdentity":        53,
	"MessageType_SignedIdentity":      54,
	"MessageType_GetFeatures":         55,
	"MessageType_EthereumGetAddress":  56,
	"MessageType_EthereumAddress":     57,
	"MessageType_EthereumSignTx":      58,
	"MessageType_EthereumTxRequest":   59,
	"MessageType_EthereumTxAck":       60,
	"MessageType_CharacterRequest":    80,
	"MessageType_CharacterAck":        81,
	"MessageType_RawTxAck":            82,
	"MessageType_ApplyPolicies":       83,
	"MessageType_FlashHash":           84,
	"MessageType_FlashWrite":          85,
	"MessageType_FlashHashResponse":   86,
	"MessageType_FlashDump":           87,
	"MessageType_FlashDumpResponse":   88,
	"MessageType_DebugLinkDecision":   100,
	"MessageType_DebugLinkGetState":   101,
	"MessageType_DebugLinkState":      102,
	"MessageType_DebugLinkStop":       103,
	"MessageType_DebugLinkLog":        104,
	"MessageType_DebugLinkFillConfig": 105,
}

func (x MessageType) Enum() *MessageType {
	p := new(MessageType)
	*p = x
	return p
}
func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}
func (x *MessageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MessageType_value, data, "MessageType")
	if err != nil {
		return err
	}
	*x = MessageType(value)
	return nil
}
func (MessageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

// *
// Request: Reset device to default state and ask for device details
// @next Features
type Initialize struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Initialize) Reset()                    { *m = Initialize{} }
func (m *Initialize) String() string            { return proto.CompactTextString(m) }
func (*Initialize) ProtoMessage()               {}
func (*Initialize) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

// *
// Request: Ask for device details (no device reset)
// @next Features
type GetFeatures struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *GetFeatures) Reset()                    { *m = GetFeatures{} }
func (m *GetFeatures) String() string            { return proto.CompactTextString(m) }
func (*GetFeatures) ProtoMessage()               {}
func (*GetFeatures) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

// *
// Response: Reports various information about the device
// @prev Initialize
// @prev GetFeatures
type Features struct {
	Vendor               *string       `protobuf:"bytes,1,opt,name=vendor" json:"vendor,omitempty"`
	MajorVersion         *uint32       `protobuf:"varint,2,opt,name=major_version,json=majorVersion" json:"major_version,omitempty"`
	MinorVersion         *uint32       `protobuf:"varint,3,opt,name=minor_version,json=minorVersion" json:"minor_version,omitempty"`
	PatchVersion         *uint32       `protobuf:"varint,4,opt,name=patch_version,json=patchVersion" json:"patch_version,omitempty"`
	BootloaderMode       *bool         `protobuf:"varint,5,opt,name=bootloader_mode,json=bootloaderMode" json:"bootloader_mode,omitempty"`
	DeviceId             *string       `protobuf:"bytes,6,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	PinProtection        *bool         `protobuf:"varint,7,opt,name=pin_protection,json=pinProtection" json:"pin_protection,omitempty"`
	PassphraseProtection *bool         `protobuf:"varint,8,opt,name=passphrase_protection,json=passphraseProtection" json:"passphrase_protection,omitempty"`
	Language             *string       `protobuf:"bytes,9,opt,name=language" json:"language,omitempty"`
	Label                *string       `protobuf:"bytes,10,opt,name=label" json:"label,omitempty"`
	Coins                []*CoinType   `protobuf:"bytes,11,rep,name=coins" json:"coins,omitempty"`
	Initialized          *bool         `protobuf:"varint,12,opt,name=initialized" json:"initialized,omitempty"`
	Revision             []byte        `protobuf:"bytes,13,opt,name=revision" json:"revision,omitempty"`
	BootloaderHash       []byte        `protobuf:"bytes,14,opt,name=bootloader_hash,json=bootloaderHash" json:"bootloader_hash,omitempty"`
	Imported             *bool         `protobuf:"varint,15,opt,name=imported" json:"imported,omitempty"`
	PinCached            *bool         `protobuf:"varint,16,opt,name=pin_cached,json=pinCached" json:"pin_cached,omitempty"`
	PassphraseCached     *bool         `protobuf:"varint,17,opt,name=passphrase_cached,json=passphraseCached" json:"passphrase_cached,omitempty"`
	Policies             []*PolicyType `protobuf:"bytes,18,rep,name=policies" json:"policies,omitempty"`
	Model                *string       `protobuf:"bytes,21,opt,name=model" json:"model,omitempty"`
	XXX_unrecognized     []byte        `json:"-"`
}

func (m *Features) Reset()                    { *m = Features{} }
func (m *Features) String() string            { return proto.CompactTextString(m) }
func (*Features) ProtoMessage()               {}
func (*Features) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *Features) GetVendor() string {
	if m != nil && m.Vendor != nil {
		return *m.Vendor
	}
	return ""
}

func (m *Features) GetMajorVersion() uint32 {
	if m != nil && m.MajorVersion != nil {
		return *m.MajorVersion
	}
	return 0
}

func (m *Features) GetMinorVersion() uint32 {
	if m != nil && m.MinorVersion != nil {
		return *m.MinorVersion
	}
	return 0
}

func (m *Features) GetPatchVersion() uint32 {
	if m != nil && m.PatchVersion != nil {
		return *m.PatchVersion
	}
	return 0
}

func (m *Features) GetBootloaderMode() bool {
	if m != nil && m.BootloaderMode != nil {
		return *m.BootloaderMode
	}
	return false
}

func (m *Features) GetDeviceId() string {
	if m != nil && m.DeviceId != nil {
		return *m.DeviceId
	}
	return ""
}

func (m *Features) GetPinProtection() bool {
	if m != nil && m.PinProtection != nil {
		return *m.PinProtection
	}
	return false
}

func (m *Features) GetPassphraseProtection() bool {
	if m != nil && m.PassphraseProtection != nil {
		return *m.PassphraseProtection
	}
	return false
}

func (m *Features) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return ""
}

func (m *Features) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *Features) GetCoins() []*CoinType {
	if m != nil {
		return m.Coins
	}
	return nil
}

func (m *Features) GetInitialized() bool {
	if m != nil && m.Initialized != nil {
		return *m.Initialized
	}
	return false
}

func (m *Features) GetRevision() []byte {
	if m != nil {
		return m.Revision
	}
	return nil
}

func (m *Features) GetBootloaderHash() []byte {
	if m != nil {
		return m.BootloaderHash
	}
	return nil
}

func (m *Features) GetImported() bool {
	if m != nil && m.Imported != nil {
		return *m.Imported
	}
	return false
}

func (m *Features) GetPinCached() bool {
	if m != nil && m.PinCached != nil {
		return *m.PinCached
	}
	return false
}

func (m *Features) GetPassphraseCached() bool {
	if m != nil && m.PassphraseCached != nil {
		return *m.PassphraseCached
	}
	return false
}

func (m *Features) GetPolicies() []*PolicyType {
	if m != nil {
		return m.Policies
	}
	return nil
}

func (m *Features) GetModel() string {
	if m != nil && m.Model != nil {
		return *m.Model
	}
	return ""
}

// *
// Request: clear session (removes cached PIN, passphrase, etc).
// @next Success
type ClearSession struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *ClearSession) Reset()                    { *m = ClearSession{} }
func (m *ClearSession) String() string            { return proto.CompactTextString(m) }
func (*ClearSession) ProtoMessage()               {}
func (*ClearSession) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

// *
// Request: change language and/or label of the device
// @next Success
// @next Failure
// @next ButtonRequest
// @next PinMatrixRequest
type ApplySettings struct {
	Language         *string `protobuf:"bytes,1,opt,name=language" json:"language,omitempty"`
	Label            *string `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	UsePassphrase    *bool   `protobuf:"varint,3,opt,name=use_passphrase,json=usePassphrase" json:"use_passphrase,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ApplySettings) Reset()                    { *m = ApplySettings{} }
func (m *ApplySettings) String() string            { return proto.CompactTextString(m) }
func (*ApplySettings) ProtoMessage()               {}
func (*ApplySettings) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *ApplySettings) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return ""
}

func (m *ApplySettings) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *ApplySettings) GetUsePassphrase() bool {
	if m != nil && m.UsePassphrase != nil {
		return *m.UsePassphrase
	}
	return false
}

// *
// Request: Starts workflow for setting/changing/removing the PIN
// @next ButtonRequest
// @next PinMatrixRequest
type ChangePin struct {
	Remove           *bool  `protobuf:"varint,1,opt,name=remove" json:"remove,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ChangePin) Reset()                    { *m = ChangePin{} }
func (m *ChangePin) String() string            { return proto.CompactTextString(m) }
func (*ChangePin) ProtoMessage()               {}
func (*ChangePin) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *ChangePin) GetRemove() bool {
	if m != nil && m.Remove != nil {
		return *m.Remove
	}
	return false
}

// *
// Request: Test if the device is alive, device sends back the message in Success response
// @next Success
type Ping struct {
	Message              *string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
	ButtonProtection     *bool   `protobuf:"varint,2,opt,name=button_protection,json=buttonProtection" json:"button_protection,omitempty"`
	PinProtection        *bool   `protobuf:"varint,3,opt,name=pin_protection,json=pinProtection" json:"pin_protection,omitempty"`
	PassphraseProtection *bool   `protobuf:"varint,4,opt,name=passphrase_protection,json=passphraseProtection" json:"passphrase_protection,omitempty"`
	XXX_unrecognized     []byte  `json:"-"`
}

func (m *Ping) Reset()                    { *m = Ping{} }
func (m *Ping) String() string            { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()               {}
func (*Ping) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

func (m *Ping) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *Ping) GetButtonProtection() bool {
	if m != nil && m.ButtonProtection != nil {
		return *m.ButtonProtection
	}
	return false
}

func (m *Ping) GetPinProtection() bool {
	if m != nil && m.PinProtection != nil {
		return *m.PinProtection
	}
	return false
}

func (m *Ping) GetPassphraseProtection() bool {
	if m != nil && m.PassphraseProtection != nil {
		return *m.PassphraseProtection
	}
	return false
}

// *
// Response: Success of the previous request
type Success struct {
	Message          *string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Success) Reset()                    { *m = Success{} }
func (m *Success) String() string            { return proto.CompactTextString(m) }
func (*Success) ProtoMessage()               {}
func (*Success) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7} }

func (m *Success) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

// *
// Response: Failure of the previous request
type Failure struct {
	Code             *FailureType `protobuf:"varint,1,opt,name=code,enum=FailureType" json:"code,omitempty"`
	Message          *string      `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Failure) Reset()                    { *m = Failure{} }
func (m *Failure) String() string            { return proto.CompactTextString(m) }
func (*Failure) ProtoMessage()               {}
func (*Failure) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{8} }

func (m *Failure) GetCode() FailureType {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return FailureType_Failure_UnexpectedMessage
}

func (m *Failure) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

// *
// Response: Device is waiting for HW button press.
// @next ButtonAck
// @next Cancel
type ButtonRequest struct {
	Code             *ButtonRequestType `protobuf:"varint,1,opt,name=code,enum=ButtonRequestType" json:"code,omitempty"`
	Data             *string            `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *ButtonRequest) Reset()                    { *m = ButtonRequest{} }
func (m *ButtonRequest) String() string            { return proto.CompactTextString(m) }
func (*ButtonRequest) ProtoMessage()               {}
func (*ButtonRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{9} }

func (m *ButtonRequest) GetCode() ButtonRequestType {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return ButtonRequestType_ButtonRequest_Other
}

func (m *ButtonRequest) GetData() string {
	if m != nil && m.Data != nil {
		return *m.Data
	}
	return ""
}

// *
// Request: Computer agrees to wait for HW button press
// @prev ButtonRequest
type ButtonAck struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *ButtonAck) Reset()                    { *m = ButtonAck{} }
func (m *ButtonAck) String() string            { return proto.CompactTextString(m) }
func (*ButtonAck) ProtoMessage()               {}
func (*ButtonAck) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{10} }

// *
// Response: Device is asking computer to show PIN matrix and awaits PIN encoded using this matrix scheme
// @next PinMatrixAck
// @next Cancel
type PinMatrixRequest struct {
	Type             *PinMatrixRequestType `protobuf:"varint,1,opt,name=type,enum=PinMatrixRequestType" json:"type,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *PinMatrixRequest) Reset()                    { *m = PinMatrixRequest{} }
func (m *PinMatrixRequest) String() string            { return proto.CompactTextString(m) }
func (*PinMatrixRequest) ProtoMessage()               {}
func (*PinMatrixRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{11} }

func (m *PinMatrixRequest) GetType() PinMatrixRequestType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return PinMatrixRequestType_PinMatrixRequestType_Current
}

// *
// Request: Computer responds with encoded PIN
// @prev PinMatrixRequest
type PinMatrixAck struct {
	Pin              *string `protobuf:"bytes,1,req,name=pin" json:"pin,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PinMatrixAck) Reset()                    { *m = PinMatrixAck{} }
func (m *PinMatrixAck) String() string            { return proto.CompactTextString(m) }
func (*PinMatrixAck) ProtoMessage()               {}
func (*PinMatrixAck) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{12} }

func (m *PinMatrixAck) GetPin() string {
	if m != nil && m.Pin != nil {
		return *m.Pin
	}
	return ""
}

// *
// Request: Abort last operation that required user interaction
// @prev ButtonRequest
// @prev PinMatrixRequest
// @prev PassphraseRequest
type Cancel struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Cancel) Reset()                    { *m = Cancel{} }
func (m *Cancel) String() string            { return proto.CompactTextString(m) }
func (*Cancel) ProtoMessage()               {}
func (*Cancel) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{13} }

// *
// Response: Device awaits encryption passphrase
// @next PassphraseAck
// @next Cancel
type PassphraseRequest struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *PassphraseRequest) Reset()                    { *m = PassphraseRequest{} }
func (m *PassphraseRequest) String() string            { return proto.CompactTextString(m) }
func (*PassphraseRequest) ProtoMessage()               {}
func (*PassphraseRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{14} }

// *
// Request: Send passphrase back
// @prev PassphraseRequest
type PassphraseAck struct {
	Passphrase       *string `protobuf:"bytes,1,req,name=passphrase" json:"passphrase,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PassphraseAck) Reset()                    { *m = PassphraseAck{} }
func (m *PassphraseAck) String() string            { return proto.CompactTextString(m) }
func (*PassphraseAck) ProtoMessage()               {}
func (*PassphraseAck) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{15} }

func (m *PassphraseAck) GetPassphrase() string {
	if m != nil && m.Passphrase != nil {
		return *m.Passphrase
	}
	return ""
}

// *
// Request: Request a sample of random data generated by hardware RNG. May be used for testing.
// @next ButtonRequest
// @next Entropy
// @next Failure
type GetEntropy struct {
	Size             *uint32 `protobuf:"varint,1,req,name=size" json:"size,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *GetEntropy) Reset()                    { *m = GetEntropy{} }
func (m *GetEntropy) String() string            { return proto.CompactTextString(m) }
func (*GetEntropy) ProtoMessage()               {}
func (*GetEntropy) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{16} }

func (m *GetEntropy) GetSize() uint32 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

// *
// Response: Reply with random data generated by internal RNG
// @prev GetEntropy
type Entropy struct {
	Entropy          []byte `protobuf:"bytes,1,req,name=entropy" json:"entropy,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Entropy) Reset()                    { *m = Entropy{} }
func (m *Entropy) String() string            { return proto.CompactTextString(m) }
func (*Entropy) ProtoMessage()               {}
func (*Entropy) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{17} }

func (m *Entropy) GetEntropy() []byte {
	if m != nil {
		return m.Entropy
	}
	return nil
}

// *
// Request: Ask device for public key corresponding to address_n path
// @next PassphraseRequest
// @next PublicKey
// @next Failure
type GetPublicKey struct {
	AddressN         []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	EcdsaCurveName   *string  `protobuf:"bytes,2,opt,name=ecdsa_curve_name,json=ecdsaCurveName" json:"ecdsa_curve_name,omitempty"`
	ShowDisplay      *bool    `protobuf:"varint,3,opt,name=show_display,json=showDisplay" json:"show_display,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GetPublicKey) Reset()                    { *m = GetPublicKey{} }
func (m *GetPublicKey) String() string            { return proto.CompactTextString(m) }
func (*GetPublicKey) ProtoMessage()               {}
func (*GetPublicKey) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{18} }

func (m *GetPublicKey) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *GetPublicKey) GetEcdsaCurveName() string {
	if m != nil && m.EcdsaCurveName != nil {
		return *m.EcdsaCurveName
	}
	return ""
}

func (m *GetPublicKey) GetShowDisplay() bool {
	if m != nil && m.ShowDisplay != nil {
		return *m.ShowDisplay
	}
	return false
}

// *
// Response: Contains public key derived from device private seed
// @prev GetPublicKey
type PublicKey struct {
	Node             *HDNodeType `protobuf:"bytes,1,req,name=node" json:"node,omitempty"`
	Xpub             *string     `protobuf:"bytes,2,opt,name=xpub" json:"xpub,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *PublicKey) Reset()                    { *m = PublicKey{} }
func (m *PublicKey) String() string            { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()               {}
func (*PublicKey) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{19} }

func (m *PublicKey) GetNode() *HDNodeType {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *PublicKey) GetXpub() string {
	if m != nil && m.Xpub != nil {
		return *m.Xpub
	}
	return ""
}

// *
// Request: Ask device for address corresponding to address_n path
// @next PassphraseRequest
// @next Address
// @next Failure
type GetAddress struct {
	AddressN         []uint32                  `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	CoinName         *string                   `protobuf:"bytes,2,opt,name=coin_name,json=coinName,def=Bitcoin" json:"coin_name,omitempty"`
	ShowDisplay      *bool                     `protobuf:"varint,3,opt,name=show_display,json=showDisplay" json:"show_display,omitempty"`
	Multisig         *MultisigRedeemScriptType `protobuf:"bytes,4,opt,name=multisig" json:"multisig,omitempty"`
	ScriptType       *InputScriptType          `protobuf:"varint,5,opt,name=script_type,json=scriptType,enum=InputScriptType,def=0" json:"script_type,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *GetAddress) Reset()                    { *m = GetAddress{} }
func (m *GetAddress) String() string            { return proto.CompactTextString(m) }
func (*GetAddress) ProtoMessage()               {}
func (*GetAddress) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{20} }

const Default_GetAddress_CoinName string = "Bitcoin"
const Default_GetAddress_ScriptType InputScriptType = InputScriptType_SPENDADDRESS

func (m *GetAddress) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *GetAddress) GetCoinName() string {
	if m != nil && m.CoinName != nil {
		return *m.CoinName
	}
	return Default_GetAddress_CoinName
}

func (m *GetAddress) GetShowDisplay() bool {
	if m != nil && m.ShowDisplay != nil {
		return *m.ShowDisplay
	}
	return false
}

func (m *GetAddress) GetMultisig() *MultisigRedeemScriptType {
	if m != nil {
		return m.Multisig
	}
	return nil
}

func (m *GetAddress) GetScriptType() InputScriptType {
	if m != nil && m.ScriptType != nil {
		return *m.ScriptType
	}
	return Default_GetAddress_ScriptType
}

// *
// Request: Ask device for Ethereum address corresponding to address_n path
// @next PassphraseRequest
// @next EthereumAddress
// @next Failure
type EthereumGetAddress struct {
	AddressN         []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	ShowDisplay      *bool    `protobuf:"varint,2,opt,name=show_display,json=showDisplay" json:"show_display,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EthereumGetAddress) Reset()                    { *m = EthereumGetAddress{} }
func (m *EthereumGetAddress) String() string            { return proto.CompactTextString(m) }
func (*EthereumGetAddress) ProtoMessage()               {}
func (*EthereumGetAddress) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{21} }

func (m *EthereumGetAddress) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *EthereumGetAddress) GetShowDisplay() bool {
	if m != nil && m.ShowDisplay != nil {
		return *m.ShowDisplay
	}
	return false
}

// *
// Response: Contains address derived from device private seed
// @prev GetAddress
type Address struct {
	Address          *string `protobuf:"bytes,1,req,name=address" json:"address,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{22} }

func (m *Address) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

// *
// Response: Contains an Ethereum address derived from device private seed
// @prev EthereumGetAddress
type EthereumAddress struct {
	Address          []byte `protobuf:"bytes,1,req,name=address" json:"address,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EthereumAddress) Reset()                    { *m = EthereumAddress{} }
func (m *EthereumAddress) String() string            { return proto.CompactTextString(m) }
func (*EthereumAddress) ProtoMessage()               {}
func (*EthereumAddress) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{23} }

func (m *EthereumAddress) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

// *
// Request: Request device to wipe all sensitive data and settings
// @next ButtonRequest
type WipeDevice struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *WipeDevice) Reset()                    { *m = WipeDevice{} }
func (m *WipeDevice) String() string            { return proto.CompactTextString(m) }
func (*WipeDevice) ProtoMessage()               {}
func (*WipeDevice) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{24} }

// *
// Request: Load seed and related internal settings from the computer
// @next ButtonRequest
// @next Success
// @next Failure
type LoadDevice struct {
	Mnemonic             *string     `protobuf:"bytes,1,opt,name=mnemonic" json:"mnemonic,omitempty"`
	Node                 *HDNodeType `protobuf:"bytes,2,opt,name=node" json:"node,omitempty"`
	Pin                  *string     `protobuf:"bytes,3,opt,name=pin" json:"pin,omitempty"`
	PassphraseProtection *bool       `protobuf:"varint,4,opt,name=passphrase_protection,json=passphraseProtection" json:"passphrase_protection,omitempty"`
	Language             *string     `protobuf:"bytes,5,opt,name=language,def=english" json:"language,omitempty"`
	Label                *string     `protobuf:"bytes,6,opt,name=label" json:"label,omitempty"`
	SkipChecksum         *bool       `protobuf:"varint,7,opt,name=skip_checksum,json=skipChecksum" json:"skip_checksum,omitempty"`
	XXX_unrecognized     []byte      `json:"-"`
}

func (m *LoadDevice) Reset()                    { *m = LoadDevice{} }
func (m *LoadDevice) String() string            { return proto.CompactTextString(m) }
func (*LoadDevice) ProtoMessage()               {}
func (*LoadDevice) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{25} }

const Default_LoadDevice_Language string = "english"

func (m *LoadDevice) GetMnemonic() string {
	if m != nil && m.Mnemonic != nil {
		return *m.Mnemonic
	}
	return ""
}

func (m *LoadDevice) GetNode() *HDNodeType {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *LoadDevice) GetPin() string {
	if m != nil && m.Pin != nil {
		return *m.Pin
	}
	return ""
}

func (m *LoadDevice) GetPassphraseProtection() bool {
	if m != nil && m.PassphraseProtection != nil {
		return *m.PassphraseProtection
	}
	return false
}

func (m *LoadDevice) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return Default_LoadDevice_Language
}

func (m *LoadDevice) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *LoadDevice) GetSkipChecksum() bool {
	if m != nil && m.SkipChecksum != nil {
		return *m.SkipChecksum
	}
	return false
}

// *
// Request: Ask device to do initialization involving user interaction
// @next EntropyRequest
// @next Failure
type ResetDevice struct {
	DisplayRandom        *bool   `protobuf:"varint,1,opt,name=display_random,json=displayRandom" json:"display_random,omitempty"`
	Strength             *uint32 `protobuf:"varint,2,opt,name=strength,def=256" json:"strength,omitempty"`
	PassphraseProtection *bool   `protobuf:"varint,3,opt,name=passphrase_protection,json=passphraseProtection" json:"passphrase_protection,omitempty"`
	PinProtection        *bool   `protobuf:"varint,4,opt,name=pin_protection,json=pinProtection" json:"pin_protection,omitempty"`
	Language             *string `protobuf:"bytes,5,opt,name=language,def=english" json:"language,omitempty"`
	Label                *string `protobuf:"bytes,6,opt,name=label" json:"label,omitempty"`
	XXX_unrecognized     []byte  `json:"-"`
}

func (m *ResetDevice) Reset()                    { *m = ResetDevice{} }
func (m *ResetDevice) String() string            { return proto.CompactTextString(m) }
func (*ResetDevice) ProtoMessage()               {}
func (*ResetDevice) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{26} }

const Default_ResetDevice_Strength uint32 = 256
const Default_ResetDevice_Language string = "english"

func (m *ResetDevice) GetDisplayRandom() bool {
	if m != nil && m.DisplayRandom != nil {
		return *m.DisplayRandom
	}
	return false
}

func (m *ResetDevice) GetStrength() uint32 {
	if m != nil && m.Strength != nil {
		return *m.Strength
	}
	return Default_ResetDevice_Strength
}

func (m *ResetDevice) GetPassphraseProtection() bool {
	if m != nil && m.PassphraseProtection != nil {
		return *m.PassphraseProtection
	}
	return false
}

func (m *ResetDevice) GetPinProtection() bool {
	if m != nil && m.PinProtection != nil {
		return *m.PinProtection
	}
	return false
}

func (m *ResetDevice) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return Default_ResetDevice_Language
}

func (m *ResetDevice) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

// *
// Response: Ask for additional entropy from host computer
// @prev ResetDevice
// @next EntropyAck
type EntropyRequest struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntropyRequest) Reset()                    { *m = EntropyRequest{} }
func (m *EntropyRequest) String() string            { return proto.CompactTextString(m) }
func (*EntropyRequest) ProtoMessage()               {}
func (*EntropyRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{27} }

// *
// Request: Provide additional entropy for seed generation function
// @prev EntropyRequest
// @next ButtonRequest
type EntropyAck struct {
	Entropy          []byte `protobuf:"bytes,1,opt,name=entropy" json:"entropy,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntropyAck) Reset()                    { *m = EntropyAck{} }
func (m *EntropyAck) String() string            { return proto.CompactTextString(m) }
func (*EntropyAck) ProtoMessage()               {}
func (*EntropyAck) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{28} }

func (m *EntropyAck) GetEntropy() []byte {
	if m != nil {
		return m.Entropy
	}
	return nil
}

// *
// Request: Start recovery workflow asking user for specific words of mnemonic
// Used to recovery device safely even on untrusted computer.
// @next WordRequest
type RecoveryDevice struct {
	WordCount            *uint32 `protobuf:"varint,1,opt,name=word_count,json=wordCount" json:"word_count,omitempty"`
	PassphraseProtection *bool   `protobuf:"varint,2,opt,name=passphrase_protection,json=passphraseProtection" json:"passphrase_protection,omitempty"`
	PinProtection        *bool   `protobuf:"varint,3,opt,name=pin_protection,json=pinProtection" json:"pin_protection,omitempty"`
	Language             *string `protobuf:"bytes,4,opt,name=language,def=english" json:"language,omitempty"`
	Label                *string `protobuf:"bytes,5,opt,name=label" json:"label,omitempty"`
	EnforceWordlist      *bool   `protobuf:"varint,6,opt,name=enforce_wordlist,json=enforceWordlist" json:"enforce_wordlist,omitempty"`
	UseCharacterCipher   *bool   `protobuf:"varint,7,opt,name=use_character_cipher,json=useCharacterCipher" json:"use_character_cipher,omitempty"`
	XXX_unrecognized     []byte  `json:"-"`
}

func (m *RecoveryDevice) Reset()                    { *m = RecoveryDevice{} }
func (m *RecoveryDevice) String() string            { return proto.CompactTextString(m) }
func (*RecoveryDevice) ProtoMessage()               {}
func (*RecoveryDevice) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{29} }

const Default_RecoveryDevice_Language string = "english"

func (m *RecoveryDevice) GetWordCount() uint32 {
	if m != nil && m.WordCount != nil {
		return *m.WordCount
	}
	return 0
}

func (m *RecoveryDevice) GetPassphraseProtection() bool {
	if m != nil && m.PassphraseProtection != nil {
		return *m.PassphraseProtection
	}
	return false
}

func (m *RecoveryDevice) GetPinProtection() bool {
	if m != nil && m.PinProtection != nil {
		return *m.PinProtection
	}
	return false
}

func (m *RecoveryDevice) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return Default_RecoveryDevice_Language
}

func (m *RecoveryDevice) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *RecoveryDevice) GetEnforceWordlist() bool {
	if m != nil && m.EnforceWordlist != nil {
		return *m.EnforceWordlist
	}
	return false
}

func (m *RecoveryDevice) GetUseCharacterCipher() bool {
	if m != nil && m.UseCharacterCipher != nil {
		return *m.UseCharacterCipher
	}
	return false
}

// *
// Response: Device is waiting for user to enter word of the mnemonic
// Its position is shown only on device's internal display.
// @prev RecoveryDevice
// @prev WordAck
type WordRequest struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *WordRequest) Reset()                    { *m = WordRequest{} }
func (m *WordRequest) String() string            { return proto.CompactTextString(m) }
func (*WordRequest) ProtoMessage()               {}
func (*WordRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{30} }

// *
// Request: Computer replies with word from the mnemonic
// @prev WordRequest
// @next WordRequest
// @next Success
// @next Failure
type WordAck struct {
	Word             *string `protobuf:"bytes,1,req,name=word" json:"word,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *WordAck) Reset()                    { *m = WordAck{} }
func (m *WordAck) String() string            { return proto.CompactTextString(m) }
func (*WordAck) ProtoMessage()               {}
func (*WordAck) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{31} }

func (m *WordAck) GetWord() string {
	if m != nil && m.Word != nil {
		return *m.Word
	}
	return ""
}

// *
// Response: Device is waiting for user to enter character of the mnemonic using cipher.
// The cipher is shown on device's internal display.
// @prev RecoveryDevice
// @prev CharacterAck
type CharacterRequest struct {
	WordPos          *uint32 `protobuf:"varint,1,req,name=word_pos,json=wordPos" json:"word_pos,omitempty"`
	CharacterPos     *uint32 `protobuf:"varint,2,req,name=character_pos,json=characterPos" json:"character_pos,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CharacterRequest) Reset()                    { *m = CharacterRequest{} }
func (m *CharacterRequest) String() string            { return proto.CompactTextString(m) }
func (*CharacterRequest) ProtoMessage()               {}
func (*CharacterRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{32} }

func (m *CharacterRequest) GetWordPos() uint32 {
	if m != nil && m.WordPos != nil {
		return *m.WordPos
	}
	return 0
}

func (m *CharacterRequest) GetCharacterPos() uint32 {
	if m != nil && m.CharacterPos != nil {
		return *m.CharacterPos
	}
	return 0
}

// *
// Request: Computer replies with character from the mnemonic using cipher
// @prev CharacterRequest
// @next CharacterRequest
// @next Failure
type CharacterAck struct {
	Character        *string `protobuf:"bytes,1,opt,name=character" json:"character,omitempty"`
	Delete           *bool   `protobuf:"varint,2,opt,name=delete" json:"delete,omitempty"`
	Done             *bool   `protobuf:"varint,3,opt,name=done" json:"done,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CharacterAck) Reset()                    { *m = CharacterAck{} }
func (m *CharacterAck) String() string            { return proto.CompactTextString(m) }
func (*CharacterAck) ProtoMessage()               {}
func (*CharacterAck) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{33} }

func (m *CharacterAck) GetCharacter() string {
	if m != nil && m.Character != nil {
		return *m.Character
	}
	return ""
}

func (m *CharacterAck) GetDelete() bool {
	if m != nil && m.Delete != nil {
		return *m.Delete
	}
	return false
}

func (m *CharacterAck) GetDone() bool {
	if m != nil && m.Done != nil {
		return *m.Done
	}
	return false
}

// *
// Request: Ask device to sign message
// @next MessageSignature
// @next Failure
type SignMessage struct {
	AddressN         []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	Message          []byte   `protobuf:"bytes,2,req,name=message" json:"message,omitempty"`
	CoinName         *string  `protobuf:"bytes,3,opt,name=coin_name,json=coinName,def=Bitcoin" json:"coin_name,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *SignMessage) Reset()                    { *m = SignMessage{} }
func (m *SignMessage) String() string            { return proto.CompactTextString(m) }
func (*SignMessage) ProtoMessage()               {}
func (*SignMessage) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{34} }

const Default_SignMessage_CoinName string = "Bitcoin"

func (m *SignMessage) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *SignMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *SignMessage) GetCoinName() string {
	if m != nil && m.CoinName != nil {
		return *m.CoinName
	}
	return Default_SignMessage_CoinName
}

// *
// Request: Ask device to verify message
// @next Success
// @next Failure
type VerifyMessage struct {
	Address          *string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	Signature        []byte  `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
	Message          []byte  `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	CoinName         *string `protobuf:"bytes,4,opt,name=coin_name,json=coinName,def=Bitcoin" json:"coin_name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *VerifyMessage) Reset()                    { *m = VerifyMessage{} }
func (m *VerifyMessage) String() string            { return proto.CompactTextString(m) }
func (*VerifyMessage) ProtoMessage()               {}
func (*VerifyMessage) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{35} }

const Default_VerifyMessage_CoinName string = "Bitcoin"

func (m *VerifyMessage) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

func (m *VerifyMessage) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *VerifyMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *VerifyMessage) GetCoinName() string {
	if m != nil && m.CoinName != nil {
		return *m.CoinName
	}
	return Default_VerifyMessage_CoinName
}

// *
// Response: Signed message
// @prev SignMessage
type MessageSignature struct {
	Address          *string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	Signature        []byte  `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MessageSignature) Reset()                    { *m = MessageSignature{} }
func (m *MessageSignature) String() string            { return proto.CompactTextString(m) }
func (*MessageSignature) ProtoMessage()               {}
func (*MessageSignature) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{36} }

func (m *MessageSignature) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

func (m *MessageSignature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// *
// Request: Ask device to encrypt message
// @next EncryptedMessage
// @next Failure
type EncryptMessage struct {
	Pubkey           []byte   `protobuf:"bytes,1,opt,name=pubkey" json:"pubkey,omitempty"`
	Message          []byte   `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	DisplayOnly      *bool    `protobuf:"varint,3,opt,name=display_only,json=displayOnly" json:"display_only,omitempty"`
	AddressN         []uint32 `protobuf:"varint,4,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	CoinName         *string  `protobuf:"bytes,5,opt,name=coin_name,json=coinName,def=Bitcoin" json:"coin_name,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EncryptMessage) Reset()                    { *m = EncryptMessage{} }
func (m *EncryptMessage) String() string            { return proto.CompactTextString(m) }
func (*EncryptMessage) ProtoMessage()               {}
func (*EncryptMessage) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{37} }

const Default_EncryptMessage_CoinName string = "Bitcoin"

func (m *EncryptMessage) GetPubkey() []byte {
	if m != nil {
		return m.Pubkey
	}
	return nil
}

func (m *EncryptMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *EncryptMessage) GetDisplayOnly() bool {
	if m != nil && m.DisplayOnly != nil {
		return *m.DisplayOnly
	}
	return false
}

func (m *EncryptMessage) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *EncryptMessage) GetCoinName() string {
	if m != nil && m.CoinName != nil {
		return *m.CoinName
	}
	return Default_EncryptMessage_CoinName
}

// *
// Response: Encrypted message
// @prev EncryptMessage
type EncryptedMessage struct {
	Nonce            []byte `protobuf:"bytes,1,opt,name=nonce" json:"nonce,omitempty"`
	Message          []byte `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	Hmac             []byte `protobuf:"bytes,3,opt,name=hmac" json:"hmac,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EncryptedMessage) Reset()                    { *m = EncryptedMessage{} }
func (m *EncryptedMessage) String() string            { return proto.CompactTextString(m) }
func (*EncryptedMessage) ProtoMessage()               {}
func (*EncryptedMessage) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{38} }

func (m *EncryptedMessage) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *EncryptedMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *EncryptedMessage) GetHmac() []byte {
	if m != nil {
		return m.Hmac
	}
	return nil
}

// *
// Request: Ask device to decrypt message
// @next Success
// @next Failure
type DecryptMessage struct {
	AddressN         []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	Nonce            []byte   `protobuf:"bytes,2,opt,name=nonce" json:"nonce,omitempty"`
	Message          []byte   `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	Hmac             []byte   `protobuf:"bytes,4,opt,name=hmac" json:"hmac,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *DecryptMessage) Reset()                    { *m = DecryptMessage{} }
func (m *DecryptMessage) String() string            { return proto.CompactTextString(m) }
func (*DecryptMessage) ProtoMessage()               {}
func (*DecryptMessage) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{39} }

func (m *DecryptMessage) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *DecryptMessage) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *DecryptMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *DecryptMessage) GetHmac() []byte {
	if m != nil {
		return m.Hmac
	}
	return nil
}

// *
// Response: Decrypted message
// @prev DecryptedMessage
type DecryptedMessage struct {
	Message          []byte  `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
	Address          *string `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DecryptedMessage) Reset()                    { *m = DecryptedMessage{} }
func (m *DecryptedMessage) String() string            { return proto.CompactTextString(m) }
func (*DecryptedMessage) ProtoMessage()               {}
func (*DecryptedMessage) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{40} }

func (m *DecryptedMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *DecryptedMessage) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

// *
// Request: Ask device to encrypt or decrypt value of given key
// @next CipheredKeyValue
// @next Failure
type CipherKeyValue struct {
	AddressN         []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	Key              *string  `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Value            []byte   `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	Encrypt          *bool    `protobuf:"varint,4,opt,name=encrypt" json:"encrypt,omitempty"`
	AskOnEncrypt     *bool    `protobuf:"varint,5,opt,name=ask_on_encrypt,json=askOnEncrypt" json:"ask_on_encrypt,omitempty"`
	AskOnDecrypt     *bool    `protobuf:"varint,6,opt,name=ask_on_decrypt,json=askOnDecrypt" json:"ask_on_decrypt,omitempty"`
	Iv               []byte   `protobuf:"bytes,7,opt,name=iv" json:"iv,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CipherKeyValue) Reset()                    { *m = CipherKeyValue{} }
func (m *CipherKeyValue) String() string            { return proto.CompactTextString(m) }
func (*CipherKeyValue) ProtoMessage()               {}
func (*CipherKeyValue) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{41} }

func (m *CipherKeyValue) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *CipherKeyValue) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *CipherKeyValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *CipherKeyValue) GetEncrypt() bool {
	if m != nil && m.Encrypt != nil {
		return *m.Encrypt
	}
	return false
}

func (m *CipherKeyValue) GetAskOnEncrypt() bool {
	if m != nil && m.AskOnEncrypt != nil {
		return *m.AskOnEncrypt
	}
	return false
}

func (m *CipherKeyValue) GetAskOnDecrypt() bool {
	if m != nil && m.AskOnDecrypt != nil {
		return *m.AskOnDecrypt
	}
	return false
}

func (m *CipherKeyValue) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

// *
// Response: Return ciphered/deciphered value
// @prev CipherKeyValue
type CipheredKeyValue struct {
	Value            []byte `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CipheredKeyValue) Reset()                    { *m = CipheredKeyValue{} }
func (m *CipheredKeyValue) String() string            { return proto.CompactTextString(m) }
func (*CipheredKeyValue) ProtoMessage()               {}
func (*CipheredKeyValue) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{42} }

func (m *CipheredKeyValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// *
// Request:  Estimated size of the transaction
// This behaves exactly like SignTx, which means that it can ask using TxRequest
// This call is non-blocking (except possible PassphraseRequest to unlock the seed)
// @next TxSize
// @next Failure
type EstimateTxSize struct {
	OutputsCount     *uint32 `protobuf:"varint,1,req,name=outputs_count,json=outputsCount" json:"outputs_count,omitempty"`
	InputsCount      *uint32 `protobuf:"varint,2,req,name=inputs_count,json=inputsCount" json:"inputs_count,omitempty"`
	CoinName         *string `protobuf:"bytes,3,opt,name=coin_name,json=coinName,def=Bitcoin" json:"coin_name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EstimateTxSize) Reset()                    { *m = EstimateTxSize{} }
func (m *EstimateTxSize) String() string            { return proto.CompactTextString(m) }
func (*EstimateTxSize) ProtoMessage()               {}
func (*EstimateTxSize) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{43} }

const Default_EstimateTxSize_CoinName string = "Bitcoin"

func (m *EstimateTxSize) GetOutputsCount() uint32 {
	if m != nil && m.OutputsCount != nil {
		return *m.OutputsCount
	}
	return 0
}

func (m *EstimateTxSize) GetInputsCount() uint32 {
	if m != nil && m.InputsCount != nil {
		return *m.InputsCount
	}
	return 0
}

func (m *EstimateTxSize) GetCoinName() string {
	if m != nil && m.CoinName != nil {
		return *m.CoinName
	}
	return Default_EstimateTxSize_CoinName
}

// *
// Response: Estimated size of the transaction
// @prev EstimateTxSize
type TxSize struct {
	TxSize           *uint32 `protobuf:"varint,1,opt,name=tx_size,json=txSize" json:"tx_size,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TxSize) Reset()                    { *m = TxSize{} }
func (m *TxSize) String() string            { return proto.CompactTextString(m) }
func (*TxSize) ProtoMessage()               {}
func (*TxSize) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{44} }

func (m *TxSize) GetTxSize() uint32 {
	if m != nil && m.TxSize != nil {
		return *m.TxSize
	}
	return 0
}

// *
// Request: Ask device to sign transaction
// @next PassphraseRequest
// @next PinMatrixRequest
// @next TxRequest
// @next Failure
type SignTx struct {
	OutputsCount     *uint32 `protobuf:"varint,1,req,name=outputs_count,json=outputsCount" json:"outputs_count,omitempty"`
	InputsCount      *uint32 `protobuf:"varint,2,req,name=inputs_count,json=inputsCount" json:"inputs_count,omitempty"`
	CoinName         *string `protobuf:"bytes,3,opt,name=coin_name,json=coinName,def=Bitcoin" json:"coin_name,omitempty"`
	Version          *uint32 `protobuf:"varint,4,opt,name=version,def=1" json:"version,omitempty"`
	LockTime         *uint32 `protobuf:"varint,5,opt,name=lock_time,json=lockTime,def=0" json:"lock_time,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SignTx) Reset()                    { *m = SignTx{} }
func (m *SignTx) String() string            { return proto.CompactTextString(m) }
func (*SignTx) ProtoMessage()               {}
func (*SignTx) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{45} }

const Default_SignTx_CoinName string = "Bitcoin"
const Default_SignTx_Version uint32 = 1
const Default_SignTx_LockTime uint32 = 0

func (m *SignTx) GetOutputsCount() uint32 {
	if m != nil && m.OutputsCount != nil {
		return *m.OutputsCount
	}
	return 0
}

func (m *SignTx) GetInputsCount() uint32 {
	if m != nil && m.InputsCount != nil {
		return *m.InputsCount
	}
	return 0
}

func (m *SignTx) GetCoinName() string {
	if m != nil && m.CoinName != nil {
		return *m.CoinName
	}
	return Default_SignTx_CoinName
}

func (m *SignTx) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_SignTx_Version
}

func (m *SignTx) GetLockTime() uint32 {
	if m != nil && m.LockTime != nil {
		return *m.LockTime
	}
	return Default_SignTx_LockTime
}

// *
// Request: Simplified transaction signing
// This method doesn't support streaming, so there are hardware limits in number of inputs and outputs.
// In case of success, the result is returned using TxRequest message.
// @next PassphraseRequest
// @next PinMatrixRequest
// @next TxRequest
// @next Failure
type SimpleSignTx struct {
	Inputs           []*TxInputType     `protobuf:"bytes,1,rep,name=inputs" json:"inputs,omitempty"`
	Outputs          []*TxOutputType    `protobuf:"bytes,2,rep,name=outputs" json:"outputs,omitempty"`
	Transactions     []*TransactionType `protobuf:"bytes,3,rep,name=transactions" json:"transactions,omitempty"`
	CoinName         *string            `protobuf:"bytes,4,opt,name=coin_name,json=coinName,def=Bitcoin" json:"coin_name,omitempty"`
	Version          *uint32            `protobuf:"varint,5,opt,name=version,def=1" json:"version,omitempty"`
	LockTime         *uint32            `protobuf:"varint,6,opt,name=lock_time,json=lockTime,def=0" json:"lock_time,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *SimpleSignTx) Reset()                    { *m = SimpleSignTx{} }
func (m *SimpleSignTx) String() string            { return proto.CompactTextString(m) }
func (*SimpleSignTx) ProtoMessage()               {}
func (*SimpleSignTx) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{46} }

const Default_SimpleSignTx_CoinName string = "Bitcoin"
const Default_SimpleSignTx_Version uint32 = 1
const Default_SimpleSignTx_LockTime uint32 = 0

func (m *SimpleSignTx) GetInputs() []*TxInputType {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *SimpleSignTx) GetOutputs() []*TxOutputType {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *SimpleSignTx) GetTransactions() []*TransactionType {
	if m != nil {
		return m.Transactions
	}
	return nil
}

func (m *SimpleSignTx) GetCoinName() string {
	if m != nil && m.CoinName != nil {
		return *m.CoinName
	}
	return Default_SimpleSignTx_CoinName
}

func (m *SimpleSignTx) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_SimpleSignTx_Version
}

func (m *SimpleSignTx) GetLockTime() uint32 {
	if m != nil && m.LockTime != nil {
		return *m.LockTime
	}
	return Default_SimpleSignTx_LockTime
}

// *
// Response: Device asks for information for signing transaction or returns the last result
// If request_index is set, device awaits TxAck message (with fields filled in according to request_type)
// If signature_index is set, 'signature' contains signed input of signature_index's input
// @prev SignTx
// @prev SimpleSignTx
// @prev TxAck
type TxRequest struct {
	RequestType      *RequestType             `protobuf:"varint,1,opt,name=request_type,json=requestType,enum=RequestType" json:"request_type,omitempty"`
	Details          *TxRequestDetailsType    `protobuf:"bytes,2,opt,name=details" json:"details,omitempty"`
	Serialized       *TxRequestSerializedType `protobuf:"bytes,3,opt,name=serialized" json:"serialized,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *TxRequest) Reset()                    { *m = TxRequest{} }
func (m *TxRequest) String() string            { return proto.CompactTextString(m) }
func (*TxRequest) ProtoMessage()               {}
func (*TxRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{47} }

func (m *TxRequest) GetRequestType() RequestType {
	if m != nil && m.RequestType != nil {
		return *m.RequestType
	}
	return RequestType_TXINPUT
}

func (m *TxRequest) GetDetails() *TxRequestDetailsType {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *TxRequest) GetSerialized() *TxRequestSerializedType {
	if m != nil {
		return m.Serialized
	}
	return nil
}

// *
// Request: Reported transaction data
// @prev TxRequest
// @next TxRequest
type TxAck struct {
	Tx               *TransactionType `protobuf:"bytes,1,opt,name=tx" json:"tx,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *TxAck) Reset()                    { *m = TxAck{} }
func (m *TxAck) String() string            { return proto.CompactTextString(m) }
func (*TxAck) ProtoMessage()               {}
func (*TxAck) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{48} }

func (m *TxAck) GetTx() *TransactionType {
	if m != nil {
		return m.Tx
	}
	return nil
}

// *
// Request: Reported raw transaction data
// @prev TxRequest
// @next TxRequest
type RawTxAck struct {
	Tx               *RawTransactionType `protobuf:"bytes,1,opt,name=tx" json:"tx,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *RawTxAck) Reset()                    { *m = RawTxAck{} }
func (m *RawTxAck) String() string            { return proto.CompactTextString(m) }
func (*RawTxAck) ProtoMessage()               {}
func (*RawTxAck) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{49} }

func (m *RawTxAck) GetTx() *RawTransactionType {
	if m != nil {
		return m.Tx
	}
	return nil
}

// *
// Request: Ask device to sign transaction
// All fields are optional from the protocol's point of view. Each field defaults to value `0` if missing.
// Note: the first at most 1024 bytes of data MUST be transmitted as part of this message.
// @next PassphraseRequest
// @next PinMatrixRequest
// @next EthereumTxRequest
// @next Failure
type EthereumSignTx struct {
	AddressN         []uint32           `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	Nonce            []byte             `protobuf:"bytes,2,opt,name=nonce" json:"nonce,omitempty"`
	GasPrice         []byte             `protobuf:"bytes,3,opt,name=gas_price,json=gasPrice" json:"gas_price,omitempty"`
	GasLimit         []byte             `protobuf:"bytes,4,opt,name=gas_limit,json=gasLimit" json:"gas_limit,omitempty"`
	To               []byte             `protobuf:"bytes,5,opt,name=to" json:"to,omitempty"`
	Value            []byte             `protobuf:"bytes,6,opt,name=value" json:"value,omitempty"`
	DataInitialChunk []byte             `protobuf:"bytes,7,opt,name=data_initial_chunk,json=dataInitialChunk" json:"data_initial_chunk,omitempty"`
	DataLength       *uint32            `protobuf:"varint,8,opt,name=data_length,json=dataLength" json:"data_length,omitempty"`
	ToAddressN       []uint32           `protobuf:"varint,9,rep,name=to_address_n,json=toAddressN" json:"to_address_n,omitempty"`
	AddressType      *OutputAddressType `protobuf:"varint,10,opt,name=address_type,json=addressType,enum=OutputAddressType" json:"address_type,omitempty"`
	ExchangeType     *ExchangeType      `protobuf:"bytes,11,opt,name=exchange_type,json=exchangeType" json:"exchange_type,omitempty"`
	ChainId          *uint32            `protobuf:"varint,12,opt,name=chain_id,json=chainId" json:"chain_id,omitempty"`
	TokenValue       []byte             `protobuf:"bytes,100,opt,name=token_value,json=tokenValue" json:"token_value,omitempty"`
	TokenTo          []byte             `protobuf:"bytes,101,opt,name=token_to,json=tokenTo" json:"token_to,omitempty"`
	TokenShortcut    *string            `protobuf:"bytes,102,opt,name=token_shortcut,json=tokenShortcut" json:"token_shortcut,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *EthereumSignTx) Reset()                    { *m = EthereumSignTx{} }
func (m *EthereumSignTx) String() string            { return proto.CompactTextString(m) }
func (*EthereumSignTx) ProtoMessage()               {}
func (*EthereumSignTx) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{50} }

func (m *EthereumSignTx) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *EthereumSignTx) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *EthereumSignTx) GetGasPrice() []byte {
	if m != nil {
		return m.GasPrice
	}
	return nil
}

func (m *EthereumSignTx) GetGasLimit() []byte {
	if m != nil {
		return m.GasLimit
	}
	return nil
}

func (m *EthereumSignTx) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *EthereumSignTx) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *EthereumSignTx) GetDataInitialChunk() []byte {
	if m != nil {
		return m.DataInitialChunk
	}
	return nil
}

func (m *EthereumSignTx) GetDataLength() uint32 {
	if m != nil && m.DataLength != nil {
		return *m.DataLength
	}
	return 0
}

func (m *EthereumSignTx) GetToAddressN() []uint32 {
	if m != nil {
		return m.ToAddressN
	}
	return nil
}

func (m *EthereumSignTx) GetAddressType() OutputAddressType {
	if m != nil && m.AddressType != nil {
		return *m.AddressType
	}
	return OutputAddressType_SPEND
}

func (m *EthereumSignTx) GetExchangeType() *ExchangeType {
	if m != nil {
		return m.ExchangeType
	}
	return nil
}

func (m *EthereumSignTx) GetChainId() uint32 {
	if m != nil && m.ChainId != nil {
		return *m.ChainId
	}
	return 0
}

func (m *EthereumSignTx) GetTokenValue() []byte {
	if m != nil {
		return m.TokenValue
	}
	return nil
}

func (m *EthereumSignTx) GetTokenTo() []byte {
	if m != nil {
		return m.TokenTo
	}
	return nil
}

func (m *EthereumSignTx) GetTokenShortcut() string {
	if m != nil && m.TokenShortcut != nil {
		return *m.TokenShortcut
	}
	return ""
}

// *
// Response: Device asks for more data from transaction payload, or returns the signature.
// If data_length is set, device awaits that many more bytes of payload.
// Otherwise, the signature_* fields contain the computed transaction signature. All three fields will be present.
// @prev EthereumSignTx
// @next EthereumTxAck
type EthereumTxRequest struct {
	DataLength       *uint32 `protobuf:"varint,1,opt,name=data_length,json=dataLength" json:"data_length,omitempty"`
	SignatureV       *uint32 `protobuf:"varint,2,opt,name=signature_v,json=signatureV" json:"signature_v,omitempty"`
	SignatureR       []byte  `protobuf:"bytes,3,opt,name=signature_r,json=signatureR" json:"signature_r,omitempty"`
	SignatureS       []byte  `protobuf:"bytes,4,opt,name=signature_s,json=signatureS" json:"signature_s,omitempty"`
	Hash             []byte  `protobuf:"bytes,5,opt,name=hash" json:"hash,omitempty"`
	SignatureDer     []byte  `protobuf:"bytes,6,opt,name=signature_der,json=signatureDer" json:"signature_der,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EthereumTxRequest) Reset()                    { *m = EthereumTxRequest{} }
func (m *EthereumTxRequest) String() string            { return proto.CompactTextString(m) }
func (*EthereumTxRequest) ProtoMessage()               {}
func (*EthereumTxRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{51} }

func (m *EthereumTxRequest) GetDataLength() uint32 {
	if m != nil && m.DataLength != nil {
		return *m.DataLength
	}
	return 0
}

func (m *EthereumTxRequest) GetSignatureV() uint32 {
	if m != nil && m.SignatureV != nil {
		return *m.SignatureV
	}
	return 0
}

func (m *EthereumTxRequest) GetSignatureR() []byte {
	if m != nil {
		return m.SignatureR
	}
	return nil
}

func (m *EthereumTxRequest) GetSignatureS() []byte {
	if m != nil {
		return m.SignatureS
	}
	return nil
}

func (m *EthereumTxRequest) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *EthereumTxRequest) GetSignatureDer() []byte {
	if m != nil {
		return m.SignatureDer
	}
	return nil
}

// *
// Request: Transaction payload data.
// @prev EthereumTxRequest
// @next EthereumTxRequest
type EthereumTxAck struct {
	DataChunk        []byte `protobuf:"bytes,1,opt,name=data_chunk,json=dataChunk" json:"data_chunk,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EthereumTxAck) Reset()                    { *m = EthereumTxAck{} }
func (m *EthereumTxAck) String() string            { return proto.CompactTextString(m) }
func (*EthereumTxAck) ProtoMessage()               {}
func (*EthereumTxAck) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{52} }

func (m *EthereumTxAck) GetDataChunk() []byte {
	if m != nil {
		return m.DataChunk
	}
	return nil
}

// *
// Request: Ask device to sign identity
// @next SignedIdentity
// @next Failure
type SignIdentity struct {
	Identity         *IdentityType `protobuf:"bytes,1,opt,name=identity" json:"identity,omitempty"`
	ChallengeHidden  []byte        `protobuf:"bytes,2,opt,name=challenge_hidden,json=challengeHidden" json:"challenge_hidden,omitempty"`
	ChallengeVisual  *string       `protobuf:"bytes,3,opt,name=challenge_visual,json=challengeVisual" json:"challenge_visual,omitempty"`
	EcdsaCurveName   *string       `protobuf:"bytes,4,opt,name=ecdsa_curve_name,json=ecdsaCurveName" json:"ecdsa_curve_name,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *SignIdentity) Reset()                    { *m = SignIdentity{} }
func (m *SignIdentity) String() string            { return proto.CompactTextString(m) }
func (*SignIdentity) ProtoMessage()               {}
func (*SignIdentity) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{53} }

func (m *SignIdentity) GetIdentity() *IdentityType {
	if m != nil {
		return m.Identity
	}
	return nil
}

func (m *SignIdentity) GetChallengeHidden() []byte {
	if m != nil {
		return m.ChallengeHidden
	}
	return nil
}

func (m *SignIdentity) GetChallengeVisual() string {
	if m != nil && m.ChallengeVisual != nil {
		return *m.ChallengeVisual
	}
	return ""
}

func (m *SignIdentity) GetEcdsaCurveName() string {
	if m != nil && m.EcdsaCurveName != nil {
		return *m.EcdsaCurveName
	}
	return ""
}

// *
// Response: Device provides signed identity
// @prev SignIdentity
type SignedIdentity struct {
	Address          *string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	PublicKey        []byte  `protobuf:"bytes,2,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	Signature        []byte  `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SignedIdentity) Reset()                    { *m = SignedIdentity{} }
func (m *SignedIdentity) String() string            { return proto.CompactTextString(m) }
func (*SignedIdentity) ProtoMessage()               {}
func (*SignedIdentity) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{54} }

func (m *SignedIdentity) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

func (m *SignedIdentity) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *SignedIdentity) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// *
// Request: Ask device to apply policy
// @next Success
// @next Failure
// @next ButtonRequest
// @next PinMatrixRequest
type ApplyPolicies struct {
	Policy           []*PolicyType `protobuf:"bytes,1,rep,name=policy" json:"policy,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *ApplyPolicies) Reset()                    { *m = ApplyPolicies{} }
func (m *ApplyPolicies) String() string            { return proto.CompactTextString(m) }
func (*ApplyPolicies) ProtoMessage()               {}
func (*ApplyPolicies) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{55} }

func (m *ApplyPolicies) GetPolicy() []*PolicyType {
	if m != nil {
		return m.Policy
	}
	return nil
}

// *
// Request: Ask the device to return a hash of flash memory
// @next FlashHashResponse
// @next Failure
type FlashHash struct {
	Address          *uint32 `protobuf:"varint,1,opt,name=address" json:"address,omitempty"`
	Length           *uint32 `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
	Challenge        []byte  `protobuf:"bytes,3,opt,name=challenge" json:"challenge,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FlashHash) Reset()                    { *m = FlashHash{} }
func (m *FlashHash) String() string            { return proto.CompactTextString(m) }
func (*FlashHash) ProtoMessage()               {}
func (*FlashHash) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{56} }

func (m *FlashHash) GetAddress() uint32 {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return 0
}

func (m *FlashHash) GetLength() uint32 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

func (m *FlashHash) GetChallenge() []byte {
	if m != nil {
		return m.Challenge
	}
	return nil
}

// *
// Request: Write a chunk of data into flash memory
// @next FlashHashResponse
// @next Failure
type FlashWrite struct {
	Address          *uint32 `protobuf:"varint,1,opt,name=address" json:"address,omitempty"`
	Data             []byte  `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FlashWrite) Reset()                    { *m = FlashWrite{} }
func (m *FlashWrite) String() string            { return proto.CompactTextString(m) }
func (*FlashWrite) ProtoMessage()               {}
func (*FlashWrite) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{57} }

func (m *FlashWrite) GetAddress() uint32 {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return 0
}

func (m *FlashWrite) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// *
// Response: Returns hash of requested data sector
// @prev FlashHash
// @prev FlashWrite
type FlashHashResponse struct {
	Data             []byte `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *FlashHashResponse) Reset()                    { *m = FlashHashResponse{} }
func (m *FlashHashResponse) String() string            { return proto.CompactTextString(m) }
func (*FlashHashResponse) ProtoMessage()               {}
func (*FlashHashResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{58} }

func (m *FlashHashResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type FlashDump struct {
	Address          *uint32 `protobuf:"varint,1,opt,name=address" json:"address,omitempty"`
	Length           *uint32 `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FlashDump) Reset()                    { *m = FlashDump{} }
func (m *FlashDump) String() string            { return proto.CompactTextString(m) }
func (*FlashDump) ProtoMessage()               {}
func (*FlashDump) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{59} }

func (m *FlashDump) GetAddress() uint32 {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return 0
}

func (m *FlashDump) GetLength() uint32 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

type FlashDumpResponse struct {
	Data             []byte `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *FlashDumpResponse) Reset()                    { *m = FlashDumpResponse{} }
func (m *FlashDumpResponse) String() string            { return proto.CompactTextString(m) }
func (*FlashDumpResponse) ProtoMessage()               {}
func (*FlashDumpResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{60} }

func (m *FlashDumpResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// *
// Request: Ask device to erase its firmware
// @next Success
// @next Failure
type FirmwareErase struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *FirmwareErase) Reset()                    { *m = FirmwareErase{} }
func (m *FirmwareErase) String() string            { return proto.CompactTextString(m) }
func (*FirmwareErase) ProtoMessage()               {}
func (*FirmwareErase) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{61} }

// *
// Request: Send firmware in binary form to the device
// @next Success
// @next Failure
type FirmwareUpload struct {
	PayloadHash      []byte `protobuf:"bytes,1,req,name=payload_hash,json=payloadHash" json:"payload_hash,omitempty"`
	Payload          []byte `protobuf:"bytes,2,req,name=payload" json:"payload,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *FirmwareUpload) Reset()                    { *m = FirmwareUpload{} }
func (m *FirmwareUpload) String() string            { return proto.CompactTextString(m) }
func (*FirmwareUpload) ProtoMessage()               {}
func (*FirmwareUpload) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{62} }

func (m *FirmwareUpload) GetPayloadHash() []byte {
	if m != nil {
		return m.PayloadHash
	}
	return nil
}

func (m *FirmwareUpload) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// *
// Request: "Press" the button on the device
// @next Success
type DebugLinkDecision struct {
	YesNo            *bool  `protobuf:"varint,1,req,name=yes_no,json=yesNo" json:"yes_no,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DebugLinkDecision) Reset()                    { *m = DebugLinkDecision{} }
func (m *DebugLinkDecision) String() string            { return proto.CompactTextString(m) }
func (*DebugLinkDecision) ProtoMessage()               {}
func (*DebugLinkDecision) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{63} }

func (m *DebugLinkDecision) GetYesNo() bool {
	if m != nil && m.YesNo != nil {
		return *m.YesNo
	}
	return false
}

// *
// Request: Computer asks for device state
// @next DebugLinkState
type DebugLinkGetState struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *DebugLinkGetState) Reset()                    { *m = DebugLinkGetState{} }
func (m *DebugLinkGetState) String() string            { return proto.CompactTextString(m) }
func (*DebugLinkGetState) ProtoMessage()               {}
func (*DebugLinkGetState) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{64} }

// *
// Response: Device current state
// @prev DebugLinkGetState
type DebugLinkState struct {
	Layout                    []byte      `protobuf:"bytes,1,opt,name=layout" json:"layout,omitempty"`
	Pin                       *string     `protobuf:"bytes,2,opt,name=pin" json:"pin,omitempty"`
	Matrix                    *string     `protobuf:"bytes,3,opt,name=matrix" json:"matrix,omitempty"`
	Mnemonic                  *string     `protobuf:"bytes,4,opt,name=mnemonic" json:"mnemonic,omitempty"`
	Node                      *HDNodeType `protobuf:"bytes,5,opt,name=node" json:"node,omitempty"`
	PassphraseProtection      *bool       `protobuf:"varint,6,opt,name=passphrase_protection,json=passphraseProtection" json:"passphrase_protection,omitempty"`
	ResetWord                 *string     `protobuf:"bytes,7,opt,name=reset_word,json=resetWord" json:"reset_word,omitempty"`
	ResetEntropy              []byte      `protobuf:"bytes,8,opt,name=reset_entropy,json=resetEntropy" json:"reset_entropy,omitempty"`
	RecoveryFakeWord          *string     `protobuf:"bytes,9,opt,name=recovery_fake_word,json=recoveryFakeWord" json:"recovery_fake_word,omitempty"`
	RecoveryWordPos           *uint32     `protobuf:"varint,10,opt,name=recovery_word_pos,json=recoveryWordPos" json:"recovery_word_pos,omitempty"`
	RecoveryCipher            *string     `protobuf:"bytes,11,opt,name=recovery_cipher,json=recoveryCipher" json:"recovery_cipher,omitempty"`
	RecoveryAutoCompletedWord *string     `protobuf:"bytes,12,opt,name=recovery_auto_completed_word,json=recoveryAutoCompletedWord" json:"recovery_auto_completed_word,omitempty"`
	FirmwareHash              []byte      `protobuf:"bytes,13,opt,name=firmware_hash,json=firmwareHash" json:"firmware_hash,omitempty"`
	StorageHash               []byte      `protobuf:"bytes,14,opt,name=storage_hash,json=storageHash" json:"storage_hash,omitempty"`
	XXX_unrecognized          []byte      `json:"-"`
}

func (m *DebugLinkState) Reset()                    { *m = DebugLinkState{} }
func (m *DebugLinkState) String() string            { return proto.CompactTextString(m) }
func (*DebugLinkState) ProtoMessage()               {}
func (*DebugLinkState) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{65} }

func (m *DebugLinkState) GetLayout() []byte {
	if m != nil {
		return m.Layout
	}
	return nil
}

func (m *DebugLinkState) GetPin() string {
	if m != nil && m.Pin != nil {
		return *m.Pin
	}
	return ""
}

func (m *DebugLinkState) GetMatrix() string {
	if m != nil && m.Matrix != nil {
		return *m.Matrix
	}
	return ""
}

func (m *DebugLinkState) GetMnemonic() string {
	if m != nil && m.Mnemonic != nil {
		return *m.Mnemonic
	}
	return ""
}

func (m *DebugLinkState) GetNode() *HDNodeType {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *DebugLinkState) GetPassphraseProtection() bool {
	if m != nil && m.PassphraseProtection != nil {
		return *m.PassphraseProtection
	}
	return false
}

func (m *DebugLinkState) GetResetWord() string {
	if m != nil && m.ResetWord != nil {
		return *m.ResetWord
	}
	return ""
}

func (m *DebugLinkState) GetResetEntropy() []byte {
	if m != nil {
		return m.ResetEntropy
	}
	return nil
}

func (m *DebugLinkState) GetRecoveryFakeWord() string {
	if m != nil && m.RecoveryFakeWord != nil {
		return *m.RecoveryFakeWord
	}
	return ""
}

func (m *DebugLinkState) GetRecoveryWordPos() uint32 {
	if m != nil && m.RecoveryWordPos != nil {
		return *m.RecoveryWordPos
	}
	return 0
}

func (m *DebugLinkState) GetRecoveryCipher() string {
	if m != nil && m.RecoveryCipher != nil {
		return *m.RecoveryCipher
	}
	return ""
}

func (m *DebugLinkState) GetRecoveryAutoCompletedWord() string {
	if m != nil && m.RecoveryAutoCompletedWord != nil {
		return *m.RecoveryAutoCompletedWord
	}
	return ""
}

func (m *DebugLinkState) GetFirmwareHash() []byte {
	if m != nil {
		return m.FirmwareHash
	}
	return nil
}

func (m *DebugLinkState) GetStorageHash() []byte {
	if m != nil {
		return m.StorageHash
	}
	return nil
}

// *
// Request: Ask device to restart
type DebugLinkStop struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *DebugLinkStop) Reset()                    { *m = DebugLinkStop{} }
func (m *DebugLinkStop) String() string            { return proto.CompactTextString(m) }
func (*DebugLinkStop) ProtoMessage()               {}
func (*DebugLinkStop) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{66} }

// *
// Response: Device wants host to log event
type DebugLinkLog struct {
	Level            *uint32 `protobuf:"varint,1,opt,name=level" json:"level,omitempty"`
	Bucket           *string `protobuf:"bytes,2,opt,name=bucket" json:"bucket,omitempty"`
	Text             *string `protobuf:"bytes,3,opt,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DebugLinkLog) Reset()                    { *m = DebugLinkLog{} }
func (m *DebugLinkLog) String() string            { return proto.CompactTextString(m) }
func (*DebugLinkLog) ProtoMessage()               {}
func (*DebugLinkLog) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{67} }

func (m *DebugLinkLog) GetLevel() uint32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *DebugLinkLog) GetBucket() string {
	if m != nil && m.Bucket != nil {
		return *m.Bucket
	}
	return ""
}

func (m *DebugLinkLog) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

// *
// Request: Ask device to fill config area with sample data (used for testing firmware upload)
type DebugLinkFillConfig struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *DebugLinkFillConfig) Reset()                    { *m = DebugLinkFillConfig{} }
func (m *DebugLinkFillConfig) String() string            { return proto.CompactTextString(m) }
func (*DebugLinkFillConfig) ProtoMessage()               {}
func (*DebugLinkFillConfig) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{68} }

func init() {
	proto.RegisterType((*Initialize)(nil), "Initialize")
	proto.RegisterType((*GetFeatures)(nil), "GetFeatures")
	proto.RegisterType((*Features)(nil), "Features")
	proto.RegisterType((*ClearSession)(nil), "ClearSession")
	proto.RegisterType((*ApplySettings)(nil), "ApplySettings")
	proto.RegisterType((*ChangePin)(nil), "ChangePin")
	proto.RegisterType((*Ping)(nil), "Ping")
	proto.RegisterType((*Success)(nil), "Success")
	proto.RegisterType((*Failure)(nil), "Failure")
	proto.RegisterType((*ButtonRequest)(nil), "ButtonRequest")
	proto.RegisterType((*ButtonAck)(nil), "ButtonAck")
	proto.RegisterType((*PinMatrixRequest)(nil), "PinMatrixRequest")
	proto.RegisterType((*PinMatrixAck)(nil), "PinMatrixAck")
	proto.RegisterType((*Cancel)(nil), "Cancel")
	proto.RegisterType((*PassphraseRequest)(nil), "PassphraseRequest")
	proto.RegisterType((*PassphraseAck)(nil), "PassphraseAck")
	proto.RegisterType((*GetEntropy)(nil), "GetEntropy")
	proto.RegisterType((*Entropy)(nil), "Entropy")
	proto.RegisterType((*GetPublicKey)(nil), "GetPublicKey")
	proto.RegisterType((*PublicKey)(nil), "PublicKey")
	proto.RegisterType((*GetAddress)(nil), "GetAddress")
	proto.RegisterType((*EthereumGetAddress)(nil), "EthereumGetAddress")
	proto.RegisterType((*Address)(nil), "Address")
	proto.RegisterType((*EthereumAddress)(nil), "EthereumAddress")
	proto.RegisterType((*WipeDevice)(nil), "WipeDevice")
	proto.RegisterType((*LoadDevice)(nil), "LoadDevice")
	proto.RegisterType((*ResetDevice)(nil), "ResetDevice")
	proto.RegisterType((*EntropyRequest)(nil), "EntropyRequest")
	proto.RegisterType((*EntropyAck)(nil), "EntropyAck")
	proto.RegisterType((*RecoveryDevice)(nil), "RecoveryDevice")
	proto.RegisterType((*WordRequest)(nil), "WordRequest")
	proto.RegisterType((*WordAck)(nil), "WordAck")
	proto.RegisterType((*CharacterRequest)(nil), "CharacterRequest")
	proto.RegisterType((*CharacterAck)(nil), "CharacterAck")
	proto.RegisterType((*SignMessage)(nil), "SignMessage")
	proto.RegisterType((*VerifyMessage)(nil), "VerifyMessage")
	proto.RegisterType((*MessageSignature)(nil), "MessageSignature")
	proto.RegisterType((*EncryptMessage)(nil), "EncryptMessage")
	proto.RegisterType((*EncryptedMessage)(nil), "EncryptedMessage")
	proto.RegisterType((*DecryptMessage)(nil), "DecryptMessage")
	proto.RegisterType((*DecryptedMessage)(nil), "DecryptedMessage")
	proto.RegisterType((*CipherKeyValue)(nil), "CipherKeyValue")
	proto.RegisterType((*CipheredKeyValue)(nil), "CipheredKeyValue")
	proto.RegisterType((*EstimateTxSize)(nil), "EstimateTxSize")
	proto.RegisterType((*TxSize)(nil), "TxSize")
	proto.RegisterType((*SignTx)(nil), "SignTx")
	proto.RegisterType((*SimpleSignTx)(nil), "SimpleSignTx")
	proto.RegisterType((*TxRequest)(nil), "TxRequest")
	proto.RegisterType((*TxAck)(nil), "TxAck")
	proto.RegisterType((*RawTxAck)(nil), "RawTxAck")
	proto.RegisterType((*EthereumSignTx)(nil), "EthereumSignTx")
	proto.RegisterType((*EthereumTxRequest)(nil), "EthereumTxRequest")
	proto.RegisterType((*EthereumTxAck)(nil), "EthereumTxAck")
	proto.RegisterType((*SignIdentity)(nil), "SignIdentity")
	proto.RegisterType((*SignedIdentity)(nil), "SignedIdentity")
	proto.RegisterType((*ApplyPolicies)(nil), "ApplyPolicies")
	proto.RegisterType((*FlashHash)(nil), "FlashHash")
	proto.RegisterType((*FlashWrite)(nil), "FlashWrite")
	proto.RegisterType((*FlashHashResponse)(nil), "FlashHashResponse")
	proto.RegisterType((*FlashDump)(nil), "FlashDump")
	proto.RegisterType((*FlashDumpResponse)(nil), "FlashDumpResponse")
	proto.RegisterType((*FirmwareErase)(nil), "FirmwareErase")
	proto.RegisterType((*FirmwareUpload)(nil), "FirmwareUpload")
	proto.RegisterType((*DebugLinkDecision)(nil), "DebugLinkDecision")
	proto.RegisterType((*DebugLinkGetState)(nil), "DebugLinkGetState")
	proto.RegisterType((*DebugLinkState)(nil), "DebugLinkState")
	proto.RegisterType((*DebugLinkStop)(nil), "DebugLinkStop")
	proto.RegisterType((*DebugLinkLog)(nil), "DebugLinkLog")
	proto.RegisterType((*DebugLinkFillConfig)(nil), "DebugLinkFillConfig")
	proto.RegisterEnum("MessageType", MessageType_name, MessageType_value)
}

func init() { proto.RegisterFile("messages.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 3347 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x5a, 0xcb, 0x73, 0xdc, 0x46,
	0x73, 0xcf, 0x3e, 0xb8, 0x8f, 0x5e, 0xec, 0x72, 0x08, 0x89, 0xf2, 0x8a, 0x12, 0x25, 0x0a, 0xd4,
	0x83, 0x92, 0x95, 0x95, 0x2d, 0x5b, 0x8e, 0xa3, 0xc4, 0xe5, 0x48, 0x24, 0x25, 0x2b, 0x7a, 0x98,
	0xc1, 0xd2, 0x92, 0xab, 0x72, 0x40, 0x81, 0xc0, 0x68, 0x77, 0xbc, 0x58, 0x00, 0x06, 0x66, 0x29,
	0xae, 0x0f, 0xb9, 0xe6, 0x9a, 0x83, 0x0f, 0x39, 0xa6, 0x2a, 0x87, 0x38, 0xe7, 0x54, 0x0e, 0x39,
	0xe4, 0x2f, 0xc8, 0x25, 0x7f, 0x47, 0x2a, 0x87, 0xef, 0xf4, 0xdd, 0xbe, 0xaa, 0xaf, 0x66, 0xa6,
	0xf1, 0x5a, 0x62, 0x69, 0x59, 0x87, 0xef, 0xb2, 0x85, 0xe9, 0xfe, 0xa1, 0xa7, 0xbb, 0xa7, 0xa7,
	0xd1, 0xd3, 0xb3, 0xd0, 0x9b, 0xd2, 0x38, 0xb6, 0x47, 0x34, 0x1e, 0x84, 0x51, 0xc0, 0x83, 0x8d,
	0x0e, 0x9f, 0x87, 0xc9, 0xc0, 0xd0, 0x00, 0x9e, 0xf9, 0x8c, 0x33, 0xdb, 0x63, 0x3f, 0x51, 0xa3,
	0x0b, 0x9d, 0xa7, 0x94, 0x3f, 0xa1, 0x36, 0x9f, 0x45, 0x34, 0x36, 0x7e, 0x5e, 0x81, 0x56, 0x32,
	0xd0, 0x2f, 0x40, 0xe3, 0x98, 0xfa, 0x6e, 0x10, 0xf5, 0x2b, 0x5b, 0x95, 0x9d, 0xb6, 0x89, 0x23,
	0x7d, 0x1b, 0xba, 0x53, 0xfb, 0x87, 0x20, 0xb2, 0x8e, 0x69, 0x14, 0xb3, 0xc0, 0xef, 0x57, 0xb7,
	0x2a, 0x3b, 0x5d, 0x53, 0x93, 0xc4, 0xd7, 0x8a, 0x26, 0x41, 0xcc, 0xcf, 0x81, 0x6a, 0x08, 0x12,
	0xc4, 0x1c, 0x28, 0xb4, 0xb9, 0x33, 0x4e, 0x41, 0x75, 0x05, 0x92, 0xc4, 0x04, 0x74, 0x0b, 0x56,
	0x8f, 0x82, 0x80, 0x7b, 0x81, 0xed, 0xd2, 0xc8, 0x9a, 0x06, 0x2e, 0xed, 0xaf, 0x6c, 0x55, 0x76,
	0x5a, 0x66, 0x2f, 0x23, 0xbf, 0x0c, 0x5c, 0xaa, 0x5f, 0x82, 0xb6, 0x4b, 0x8f, 0x99, 0x43, 0x2d,
	0xe6, 0xf6, 0x1b, 0x52, 0xe5, 0x96, 0x22, 0x3c, 0x73, 0xf5, 0x1b, 0xd0, 0x0b, 0x99, 0x6f, 0x09,
	0x1f, 0x50, 0x87, 0x8b, 0xb9, 0x9a, 0x52, 0x48, 0x37, 0x64, 0xfe, 0x41, 0x4a, 0xd4, 0x3f, 0x83,
	0xf5, 0xd0, 0x8e, 0xe3, 0x70, 0x1c, 0xd9, 0x31, 0xcd, 0xa3, 0x5b, 0x12, 0x7d, 0x3e, 0x63, 0xe6,
	0x5e, 0xda, 0x80, 0x96, 0x67, 0xfb, 0xa3, 0x99, 0x3d, 0xa2, 0xfd, 0xb6, 0x9a, 0x37, 0x19, 0xeb,
	0xe7, 0x61, 0xc5, 0xb3, 0x8f, 0xa8, 0xd7, 0x07, 0xc9, 0x50, 0x03, 0xfd, 0x2a, 0xac, 0x38, 0x01,
	0xf3, 0xe3, 0x7e, 0x67, 0xab, 0xb6, 0xd3, 0xb9, 0xdf, 0x1e, 0xec, 0x06, 0xcc, 0x3f, 0x9c, 0x87,
	0xd4, 0x54, 0x74, 0x7d, 0x0b, 0x3a, 0x2c, 0x5d, 0x25, 0xb7, 0xaf, 0xc9, 0xd9, 0xf3, 0x24, 0x31,
	0x69, 0x44, 0x8f, 0x99, 0x74, 0x5b, 0x77, 0xab, 0xb2, 0xa3, 0x99, 0xe9, 0x78, 0xc1, 0x65, 0x63,
	0x3b, 0x1e, 0xf7, 0x7b, 0x12, 0x92, 0x73, 0xd9, 0x37, 0x76, 0x3c, 0x16, 0x42, 0xd8, 0x34, 0x0c,
	0x22, 0x4e, 0xdd, 0xfe, 0xaa, 0x9c, 0x23, 0x1d, 0xeb, 0x9b, 0x00, 0xc2, 0x63, 0x8e, 0xed, 0x8c,
	0xa9, 0xdb, 0x27, 0x92, 0xdb, 0x0e, 0x99, 0xbf, 0x2b, 0x09, 0xfa, 0xc7, 0xb0, 0x96, 0xf3, 0x14,
	0xa2, 0xd6, 0x24, 0x8a, 0x64, 0x0c, 0x04, 0xdf, 0x82, 0x56, 0x18, 0x78, 0xcc, 0x61, 0x34, 0xee,
	0xeb, 0xd2, 0xe4, 0xce, 0xe0, 0x40, 0x10, 0xe6, 0xd2, 0xe8, 0x94, 0x29, 0xdc, 0x25, 0x56, 0xd8,
	0xeb, 0xaf, 0x2b, 0x77, 0xc9, 0x81, 0xd1, 0x03, 0x6d, 0xd7, 0xa3, 0x76, 0x34, 0xa4, 0xb1, 0xb0,
	0xcf, 0x18, 0x43, 0xf7, 0x51, 0x18, 0x7a, 0xf3, 0x21, 0xe5, 0x9c, 0xf9, 0xa3, 0xb8, 0xb0, 0x02,
	0x95, 0x65, 0x2b, 0x50, 0xcd, 0xaf, 0xc0, 0x0d, 0xe8, 0xcd, 0xc4, 0x0a, 0xa7, 0x9a, 0xca, 0x00,
	0x6d, 0x99, 0xdd, 0x59, 0x4c, 0x0f, 0x52, 0xa2, 0xb1, 0x0d, 0xed, 0xdd, 0xb1, 0xed, 0x8f, 0xe8,
	0x01, 0xf3, 0xc5, 0x86, 0x88, 0xe8, 0x34, 0x38, 0x56, 0x73, 0xb4, 0x4c, 0x1c, 0x19, 0xff, 0x5e,
	0x81, 0xfa, 0x01, 0xf3, 0x47, 0x7a, 0x1f, 0x9a, 0xb8, 0xf5, 0x50, 0x8b, 0x64, 0x28, 0xbc, 0x75,
	0x34, 0xe3, 0x3c, 0x28, 0x44, 0x60, 0x55, 0x79, 0x4b, 0x31, 0x72, 0xf1, 0x74, 0x3a, 0x56, 0x6b,
	0xbf, 0x29, 0x56, 0xeb, 0xcb, 0x63, 0xd5, 0xd8, 0x86, 0xe6, 0x70, 0xe6, 0x38, 0x34, 0x8e, 0x97,
	0x6b, 0x6b, 0xec, 0x43, 0xf3, 0x89, 0xcd, 0xbc, 0x59, 0x44, 0xf5, 0x2d, 0xa8, 0x3b, 0x62, 0xcb,
	0x09, 0x44, 0xef, 0xbe, 0x36, 0x40, 0xba, 0x5c, 0x36, 0xc9, 0xc9, 0x8b, 0xa9, 0x16, 0xc5, 0x3c,
	0x87, 0xee, 0x63, 0x69, 0x9b, 0x49, 0x7f, 0x9c, 0xd1, 0x98, 0xeb, 0x37, 0x0b, 0xc2, 0xf4, 0x41,
	0x81, 0x9b, 0x13, 0xa9, 0x43, 0xdd, 0xb5, 0xb9, 0x8d, 0xf2, 0xe4, 0xb3, 0xd1, 0x81, 0xb6, 0x82,
	0x3f, 0x72, 0x26, 0xc6, 0x57, 0x40, 0x0e, 0x98, 0xff, 0xd2, 0xe6, 0x11, 0x3b, 0x49, 0x84, 0xdf,
	0x86, 0xba, 0xc8, 0x73, 0x28, 0x7c, 0x7d, 0xb0, 0x08, 0x50, 0xf2, 0x05, 0xc4, 0xd8, 0x02, 0x2d,
	0xe5, 0x3e, 0x72, 0x26, 0x3a, 0x81, 0x5a, 0xc8, 0xfc, 0x7e, 0x65, 0xab, 0xba, 0xd3, 0x36, 0xc5,
	0xa3, 0xd1, 0x82, 0xc6, 0xae, 0xed, 0x3b, 0xd4, 0x33, 0xce, 0xc1, 0x5a, 0x16, 0x0f, 0x28, 0xca,
	0xb8, 0x07, 0xdd, 0x8c, 0x28, 0x24, 0x5c, 0x01, 0xc8, 0x85, 0x92, 0x12, 0x94, 0xa3, 0x18, 0x5b,
	0x00, 0x4f, 0x29, 0xdf, 0xf7, 0x79, 0x14, 0x84, 0x73, 0x61, 0x5f, 0xcc, 0x7e, 0x52, 0xb8, 0xae,
	0x29, 0x9f, 0xc5, 0xc2, 0x24, 0xec, 0x3e, 0x34, 0xa9, 0x7a, 0x94, 0x08, 0xcd, 0x4c, 0x86, 0xc6,
	0x09, 0x68, 0x4f, 0x29, 0x3f, 0x98, 0x1d, 0x79, 0xcc, 0x79, 0x4e, 0xe7, 0x22, 0xe5, 0xd9, 0xae,
	0x1b, 0xd1, 0x38, 0xb6, 0x84, 0xfa, 0xb5, 0x9d, 0xae, 0xd9, 0x42, 0xc2, 0x2b, 0x7d, 0x07, 0x08,
	0x75, 0xdc, 0xd8, 0xb6, 0x9c, 0x59, 0x74, 0x4c, 0x2d, 0xdf, 0x9e, 0x26, 0x2b, 0xd4, 0x93, 0xf4,
	0x5d, 0x41, 0x7e, 0x65, 0x4f, 0xa9, 0x7e, 0x0d, 0xb4, 0x78, 0x1c, 0xbc, 0xb3, 0x5c, 0x16, 0x87,
	0x9e, 0x3d, 0xc7, 0x70, 0xeb, 0x08, 0xda, 0x9e, 0x22, 0x19, 0x7f, 0x03, 0xed, 0x6c, 0xda, 0xab,
	0x50, 0xf7, 0xd5, 0x3a, 0x56, 0xe5, 0x56, 0xfe, 0x66, 0xef, 0x55, 0xe0, 0x62, 0x4c, 0xf8, 0xb8,
	0x80, 0x27, 0xe1, 0xec, 0x28, 0x59, 0x40, 0xf1, 0x6c, 0xfc, 0x5f, 0x45, 0xfa, 0xe0, 0x91, 0x52,
	0xef, 0x6c, 0xd5, 0xaf, 0x43, 0x5b, 0xe4, 0xc1, 0x9c, 0xce, 0x0f, 0x9b, 0x8f, 0x19, 0x17, 0x34,
	0xb3, 0x25, 0x7e, 0xdf, 0x53, 0x6d, 0xfd, 0x01, 0xb4, 0xa6, 0x33, 0x8f, 0xb3, 0x98, 0x8d, 0xe4,
	0xb6, 0xe8, 0xdc, 0xbf, 0x38, 0x78, 0x89, 0x04, 0x93, 0xba, 0x94, 0x4e, 0x87, 0x4e, 0xc4, 0x42,
	0x15, 0x1c, 0x29, 0x54, 0xff, 0x1a, 0x3a, 0xb1, 0xa4, 0x5b, 0x32, 0xa4, 0x56, 0x64, 0x48, 0x91,
	0xc1, 0x33, 0x3f, 0x9c, 0xf1, 0xec, 0x85, 0x87, 0xda, 0xf0, 0x60, 0xff, 0xd5, 0xde, 0xa3, 0xbd,
	0x3d, 0x73, 0x7f, 0x38, 0x34, 0x21, 0x4e, 0x39, 0xc6, 0x21, 0xe8, 0xfb, 0x7c, 0x4c, 0x23, 0x3a,
	0x9b, 0xbe, 0xaf, 0xcd, 0x8b, 0xd6, 0x54, 0x4f, 0x2f, 0xc2, 0x36, 0x34, 0x13, 0x51, 0x7d, 0x68,
	0xe2, 0x9b, 0x18, 0x6d, 0xc9, 0xd0, 0xf8, 0x18, 0x56, 0x93, 0xa9, 0x97, 0x80, 0xb5, 0x0c, 0xac,
	0x01, 0xbc, 0x61, 0x21, 0xdd, 0x93, 0x9f, 0x49, 0xe3, 0x77, 0x15, 0x80, 0x17, 0x81, 0xed, 0xaa,
	0xa1, 0xc8, 0xaa, 0x53, 0x9f, 0x4e, 0x03, 0x9f, 0x39, 0x49, 0x56, 0x4d, 0xc6, 0x69, 0x08, 0x54,
	0xa5, 0x53, 0x4b, 0x42, 0x00, 0xf7, 0x54, 0x4d, 0xbe, 0x27, 0x1e, 0x3f, 0x28, 0x5f, 0xe9, 0xdb,
	0xb9, 0xcc, 0xbe, 0xa2, 0x02, 0x81, 0xfa, 0x23, 0x8f, 0xc5, 0xe3, 0xb2, 0x14, 0xdf, 0xc8, 0xa7,
	0xf8, 0x6d, 0xe8, 0xc6, 0x13, 0x16, 0x5a, 0xce, 0x98, 0x3a, 0x93, 0x78, 0x36, 0xc5, 0x2f, 0xbe,
	0x26, 0x88, 0xbb, 0x48, 0x33, 0xfe, 0xbf, 0x02, 0x1d, 0x93, 0xc6, 0x94, 0xa3, 0xcd, 0x37, 0xa0,
	0x87, 0x0b, 0x60, 0x45, 0xb6, 0xef, 0x06, 0x53, 0xcc, 0xf5, 0x5d, 0xa4, 0x9a, 0x92, 0xa8, 0x5f,
	0x85, 0x56, 0xcc, 0x23, 0xea, 0x8f, 0xf8, 0x58, 0x95, 0x3f, 0x0f, 0x6b, 0xf7, 0x1f, 0x7c, 0x61,
	0xa6, 0xc4, 0xe5, 0xc6, 0xd6, 0xce, 0x30, 0xf6, 0x74, 0xe2, 0xaf, 0x97, 0x25, 0xfe, 0x0f, 0xf7,
	0x89, 0x41, 0xa0, 0x87, 0x59, 0x26, 0x49, 0x65, 0x37, 0x01, 0x90, 0x22, 0xf2, 0x58, 0x21, 0xf5,
	0x54, 0xf2, 0xa9, 0xe7, 0x5f, 0xab, 0xd0, 0x33, 0xa9, 0x13, 0x1c, 0xd3, 0x68, 0x8e, 0xbe, 0xda,
	0x04, 0x78, 0x17, 0x44, 0xae, 0xe5, 0x04, 0x33, 0x9f, 0x4b, 0x7c, 0xd7, 0x6c, 0x0b, 0xca, 0xae,
	0x20, 0x2c, 0x77, 0x41, 0xf5, 0x37, 0xb9, 0xa0, 0xf6, 0x6b, 0x2e, 0xa8, 0xff, 0xaa, 0x0b, 0x56,
	0xf2, 0x61, 0x71, 0x1b, 0x08, 0xf5, 0xdf, 0x06, 0x91, 0x43, 0x2d, 0xa1, 0xab, 0xc7, 0x62, 0x2e,
	0x7d, 0xd4, 0x32, 0x57, 0x91, 0xfe, 0x06, 0xc9, 0xfa, 0x27, 0x70, 0x5e, 0x14, 0x09, 0xce, 0xd8,
	0x8e, 0x6c, 0x87, 0xd3, 0xc8, 0x72, 0x58, 0x38, 0xa6, 0x11, 0x06, 0x92, 0x3e, 0x8b, 0xe9, 0x6e,
	0xc2, 0xda, 0x95, 0x1c, 0x51, 0x4f, 0x8b, 0xb7, 0x13, 0xe7, 0x6e, 0x42, 0x53, 0x0c, 0x85, 0x67,
	0x75, 0xa8, 0x8b, 0xe9, 0x70, 0xb7, 0xca, 0x67, 0xc3, 0x04, 0x92, 0x0a, 0x48, 0x3e, 0x63, 0x17,
	0xa1, 0x25, 0x9d, 0x1a, 0x06, 0x31, 0x7e, 0x1f, 0x9a, 0x62, 0x7c, 0x10, 0xc4, 0x22, 0xa0, 0x33,
	0x55, 0x04, 0xbf, 0x2a, 0xf9, 0x5a, 0x4a, 0x3c, 0x08, 0x62, 0xe3, 0x7b, 0xd0, 0x52, 0x99, 0x62,
	0xde, 0xcb, 0xd0, 0x4e, 0xf9, 0xb8, 0x8b, 0x33, 0x82, 0x28, 0x69, 0x5c, 0xea, 0x51, 0x4e, 0x71,
	0x51, 0x70, 0x24, 0xbf, 0xc0, 0x81, 0x9f, 0x14, 0x45, 0xf2, 0xd9, 0xf8, 0x01, 0x3a, 0x43, 0x36,
	0xf2, 0x5f, 0x62, 0x49, 0x73, 0x66, 0x32, 0x2b, 0x14, 0x05, 0x32, 0xe3, 0x24, 0x95, 0x50, 0x21,
	0xb5, 0xd7, 0x96, 0xa4, 0x76, 0xe3, 0x1f, 0x2b, 0xd0, 0x7d, 0x4d, 0x23, 0xf6, 0x76, 0x9e, 0x4c,
	0x57, 0xc8, 0x61, 0x95, 0x5c, 0xc2, 0x13, 0x16, 0xc6, 0x6c, 0xe4, 0xcb, 0x53, 0x8b, 0x34, 0x43,
	0x33, 0x33, 0x42, 0x5e, 0x93, 0x9a, 0x8a, 0xe8, 0x52, 0x4d, 0xea, 0xcb, 0x34, 0xf9, 0x5b, 0x20,
	0xa8, 0xc2, 0x30, 0x2f, 0xf3, 0x43, 0x74, 0x31, 0x7e, 0xa9, 0x88, 0xed, 0xe7, 0x44, 0xf3, 0x90,
	0x27, 0x66, 0x5d, 0x80, 0x46, 0x38, 0x3b, 0x9a, 0xd0, 0x64, 0xbf, 0xe1, 0x68, 0xb1, 0xaa, 0xca,
	0xa9, 0x7d, 0x0d, 0xb4, 0x24, 0x43, 0x05, 0xbe, 0x97, 0x7e, 0xf5, 0x90, 0xf6, 0xad, 0xef, 0x2d,
	0x94, 0x05, 0xf5, 0xb3, 0xbe, 0xad, 0x2b, 0xcb, 0xcc, 0x7e, 0x0d, 0x04, 0x35, 0xa5, 0x6e, 0xa2,
	0xeb, 0x79, 0x58, 0xf1, 0x03, 0xdf, 0xa1, 0xa8, 0xaa, 0x1a, 0x9c, 0xa1, 0xa9, 0x0e, 0xf5, 0xf1,
	0xd4, 0x76, 0xd0, 0xef, 0xf2, 0xd9, 0xf8, 0x11, 0x7a, 0x7b, 0xb4, 0xe0, 0x81, 0x33, 0xe3, 0x28,
	0x9d, 0xb2, 0xba, 0x64, 0xca, 0x5a, 0xf9, 0x94, 0xf5, 0xdc, 0x94, 0x4f, 0x80, 0xe0, 0x94, 0x99,
	0x29, 0x0b, 0xb5, 0x6f, 0x4e, 0x42, 0x6e, 0x6d, 0xab, 0x85, 0xb5, 0x35, 0xfe, 0xa7, 0x02, 0x3d,
	0xb5, 0xcd, 0x9f, 0xd3, 0xf9, 0x6b, 0xdb, 0x9b, 0xfd, 0x8a, 0xee, 0x04, 0x6a, 0x62, 0x5d, 0x95,
	0x14, 0xf1, 0x28, 0xac, 0x39, 0x16, 0xef, 0xa1, 0xd6, 0x6a, 0xa0, 0x72, 0xae, 0xd4, 0x0f, 0xd3,
	0x7d, 0x32, 0xd4, 0xaf, 0x43, 0xcf, 0x8e, 0x27, 0x56, 0xe0, 0x5b, 0x09, 0x40, 0x9d, 0x7c, 0x35,
	0x3b, 0x9e, 0x7c, 0xeb, 0xef, 0x9f, 0x42, 0xb9, 0xca, 0x4c, 0x4c, 0x67, 0x0a, 0x85, 0xa6, 0xeb,
	0x3d, 0xa8, 0xb2, 0x63, 0x99, 0xb9, 0x34, 0xb3, 0xca, 0x8e, 0x8d, 0x1d, 0x20, 0xca, 0x18, 0xea,
	0xa6, 0xe6, 0xa4, 0xfa, 0x55, 0x72, 0xfa, 0x19, 0xff, 0x00, 0xbd, 0xfd, 0x98, 0xb3, 0xa9, 0xcd,
	0xe9, 0xe1, 0xc9, 0x90, 0xfd, 0x44, 0x45, 0x22, 0x0a, 0x66, 0x3c, 0x9c, 0xf1, 0x38, 0xcd, 0xfd,
	0x32, 0x11, 0x21, 0x51, 0xa5, 0xff, 0x6b, 0xa0, 0x31, 0x3f, 0x87, 0x51, 0xc9, 0xaa, 0xa3, 0x68,
	0x0a, 0xf2, 0x7e, 0xb9, 0xe0, 0x1a, 0x34, 0x70, 0xde, 0x8f, 0xa0, 0xc9, 0x4f, 0x2c, 0x2c, 0x9d,
	0xc5, 0xd7, 0xa6, 0xc1, 0x25, 0xc3, 0xf8, 0x8f, 0x0a, 0x34, 0xc4, 0xf6, 0x3c, 0x3c, 0xf9, 0xd3,
	0xea, 0xa6, 0x5f, 0x82, 0x66, 0xa1, 0x77, 0xf1, 0xb0, 0xf2, 0xa9, 0x99, 0x50, 0xf4, 0x2b, 0xd0,
	0xf6, 0x02, 0x67, 0x62, 0x71, 0x86, 0x3b, 0xad, 0xfb, 0xb0, 0xf2, 0x89, 0xd9, 0x12, 0xb4, 0x43,
	0x36, 0xa5, 0xc6, 0xef, 0x2b, 0xa0, 0x0d, 0xd9, 0x34, 0xf4, 0x28, 0xea, 0x7e, 0x1d, 0x1a, 0x4a,
	0x05, 0x19, 0x4b, 0x9d, 0xfb, 0xda, 0xe0, 0xf0, 0x44, 0xd6, 0x9c, 0xb2, 0xae, 0x42, 0x9e, 0x7e,
	0x0b, 0x9a, 0x68, 0x4c, 0xbf, 0x2a, 0x61, 0xdd, 0xc1, 0xe1, 0xc9, 0xb7, 0x92, 0x22, 0x71, 0x09,
	0x57, 0xff, 0x1c, 0x34, 0x1e, 0xd9, 0x7e, 0x6c, 0xcb, 0x6f, 0x66, 0xdc, 0xaf, 0x49, 0x34, 0x19,
	0x1c, 0x66, 0x44, 0xf9, 0x42, 0x01, 0xf5, 0x7e, 0x69, 0x31, 0x6f, 0xf8, 0xca, 0xd9, 0x86, 0x37,
	0x4e, 0x1b, 0xfe, 0x6f, 0x15, 0x68, 0x1f, 0xa6, 0x07, 0xb7, 0x7b, 0xa0, 0x45, 0xea, 0xd1, 0xca,
	0x1d, 0xe0, 0xb4, 0x41, 0xfe, 0xdc, 0xd6, 0x89, 0xb2, 0x81, 0x7e, 0x0f, 0x9a, 0x2e, 0xe5, 0x36,
	0xf3, 0x62, 0x2c, 0x3f, 0xd7, 0x07, 0xa9, 0xb4, 0x3d, 0xc5, 0x50, 0x8e, 0x40, 0x94, 0xfe, 0x25,
	0x40, 0x4c, 0xa3, 0xa4, 0x99, 0x52, 0x93, 0xef, 0xf4, 0xb3, 0x77, 0x86, 0x29, 0x4f, 0xbe, 0x96,
	0xc3, 0x1a, 0xb7, 0x61, 0xe5, 0x50, 0x1e, 0x11, 0xb7, 0xa0, 0xca, 0x4f, 0xa4, 0x6a, 0x65, 0x1e,
	0xac, 0xf2, 0x13, 0xe3, 0x1e, 0xb4, 0x4c, 0xfb, 0x9d, 0x42, 0x6f, 0xe7, 0xd0, 0xe7, 0x06, 0x82,
	0x5c, 0xf2, 0xc2, 0x1f, 0x6a, 0xd0, 0x4b, 0x2a, 0x75, 0x0c, 0x80, 0x0f, 0xc8, 0x85, 0x97, 0xa0,
	0x3d, 0xb2, 0x63, 0x2b, 0x8c, 0x98, 0x93, 0xe4, 0x95, 0xd6, 0xc8, 0x8e, 0x0f, 0xc4, 0x38, 0x61,
	0x7a, 0x6c, 0xca, 0x38, 0xe6, 0x44, 0xc1, 0x7c, 0x21, 0xc6, 0x22, 0x23, 0xf0, 0x40, 0xae, 0x9e,
	0x66, 0x56, 0x79, 0x90, 0xed, 0xfe, 0x46, 0x3e, 0x3b, 0xdd, 0x05, 0x5d, 0x9c, 0xbf, 0x2d, 0xec,
	0x3d, 0x59, 0xce, 0x78, 0xe6, 0x4f, 0x30, 0x8f, 0x10, 0xc1, 0xc1, 0x6e, 0xe2, 0xae, 0xa0, 0xeb,
	0x57, 0xa1, 0x23, 0xd1, 0x9e, 0x2a, 0x8d, 0x5b, 0x72, 0x97, 0x82, 0x20, 0xbd, 0x50, 0x75, 0xf1,
	0x16, 0x68, 0x3c, 0xb0, 0x32, 0x23, 0xdb, 0xd2, 0x48, 0xe0, 0xc1, 0xa3, 0xc4, 0xcc, 0x07, 0xa0,
	0x25, 0x6c, 0x19, 0x0e, 0x80, 0xcd, 0x02, 0x15, 0xe1, 0x08, 0x53, 0x41, 0x61, 0x67, 0x03, 0xfd,
	0x3e, 0x74, 0xe9, 0x89, 0x23, 0x7b, 0x35, 0xea, 0xbd, 0x8e, 0xf4, 0x7e, 0x77, 0xb0, 0x8f, 0x54,
	0x15, 0xea, 0x34, 0x37, 0x12, 0xb5, 0x96, 0x33, 0xb6, 0x99, 0x6f, 0x31, 0xd5, 0x62, 0xeb, 0x9a,
	0x4d, 0x39, 0x7e, 0xe6, 0x0a, 0x43, 0x78, 0x30, 0xa1, 0xbe, 0xa5, 0x5c, 0xe2, 0x4a, 0x7b, 0x41,
	0x92, 0x54, 0xae, 0xbc, 0x08, 0x2d, 0x05, 0xe0, 0x41, 0x9f, 0xaa, 0x4f, 0x88, 0x1c, 0x1f, 0x06,
	0xa2, 0x86, 0x55, 0xac, 0x78, 0x1c, 0x44, 0xdc, 0x99, 0xf1, 0xfe, 0x5b, 0xf9, 0x0d, 0xe8, 0x4a,
	0xea, 0x10, 0x89, 0xc6, 0xff, 0x56, 0x60, 0x2d, 0x59, 0xff, 0x6c, 0x37, 0x2c, 0x78, 0xb0, 0x72,
	0xca, 0x83, 0x57, 0xa1, 0x93, 0x56, 0x14, 0xd6, 0x31, 0x36, 0x5f, 0x21, 0x25, 0xbd, 0x2e, 0x02,
	0x22, 0x8c, 0x89, 0x0c, 0x60, 0x16, 0x01, 0x31, 0xc6, 0x45, 0x06, 0x18, 0xca, 0xaf, 0xa8, 0x1d,
	0x8f, 0x31, 0x36, 0xe4, 0xb3, 0x3c, 0x4d, 0xa5, 0x2f, 0xb9, 0x34, 0xc2, 0x28, 0xd1, 0x52, 0xe2,
	0x1e, 0x8d, 0x8c, 0x01, 0x74, 0x33, 0x8b, 0xc4, 0x46, 0xd8, 0x04, 0xa9, 0x3a, 0x46, 0x8d, 0xfa,
	0xac, 0xb4, 0x05, 0x45, 0x86, 0x8b, 0xf1, 0x5f, 0x32, 0x03, 0x8e, 0xfc, 0x67, 0x2e, 0xf5, 0x39,
	0xe3, 0x73, 0xfd, 0x36, 0xb4, 0x18, 0x3e, 0xe3, 0xf6, 0xe9, 0x0e, 0x12, 0xa6, 0x3a, 0xa3, 0xb3,
	0x0c, 0x4a, 0x9c, 0xb1, 0xed, 0x09, 0x3f, 0x51, 0x6b, 0xcc, 0x5c, 0x97, 0xfa, 0xb8, 0x33, 0x56,
	0x53, 0xfa, 0x37, 0x92, 0x5c, 0x84, 0x1e, 0xb3, 0x78, 0x66, 0x7b, 0x78, 0x30, 0xcd, 0xa0, 0xaf,
	0x25, 0xb9, 0xb4, 0x69, 0x52, 0x2f, 0x6b, 0x9a, 0x18, 0x23, 0xe8, 0x09, 0xd5, 0xa9, 0x9b, 0x2a,
	0xbf, 0xbc, 0x2c, 0xdc, 0x04, 0x08, 0x65, 0xf7, 0xc4, 0x4a, 0x2a, 0x02, 0xcd, 0x6c, 0x87, 0x69,
	0x3f, 0xa5, 0x50, 0x35, 0xd6, 0x16, 0xab, 0xc6, 0xcf, 0xb1, 0xdb, 0x79, 0x90, 0x34, 0x49, 0xb7,
	0xa1, 0x21, 0x1b, 0xa6, 0x73, 0xfc, 0x4c, 0x14, 0x7a, 0xa9, 0xc8, 0x32, 0xfe, 0x1e, 0xda, 0x4f,
	0x3c, 0x3b, 0x1e, 0xcb, 0x3e, 0xef, 0x82, 0x66, 0xdd, 0x4c, 0xb3, 0x0b, 0xd0, 0xf0, 0x72, 0xc7,
	0x58, 0x13, 0x47, 0x78, 0x6c, 0x50, 0xae, 0x49, 0x54, 0x4a, 0x09, 0xc6, 0x43, 0x00, 0x29, 0xfc,
	0x4d, 0xc4, 0x38, 0x3d, 0x43, 0x7a, 0xbe, 0x91, 0xa7, 0x61, 0x23, 0xef, 0x16, 0xac, 0xa5, 0x8a,
	0x99, 0x34, 0x0e, 0x03, 0x3f, 0xce, 0x3a, 0x7e, 0x95, 0x1c, 0xf0, 0x2b, 0xb4, 0x60, 0x6f, 0x36,
	0x0d, 0x7f, 0xbb, 0x05, 0xe9, 0x3c, 0xe2, 0xf5, 0x33, 0xe7, 0x59, 0x85, 0xee, 0x13, 0x16, 0x4d,
	0xdf, 0xd9, 0x11, 0xdd, 0x97, 0xcd, 0xba, 0x97, 0xd0, 0x4b, 0x08, 0xdf, 0x85, 0x5e, 0x60, 0xbb,
	0xa2, 0x5e, 0x08, 0xed, 0xb9, 0x78, 0x54, 0xdd, 0x74, 0xd5, 0x45, 0xe9, 0x20, 0x2d, 0x71, 0x31,
	0x0e, 0x93, 0x13, 0x0f, 0x0e, 0x8d, 0x3b, 0xb0, 0xb6, 0x47, 0x8f, 0x66, 0xa3, 0x17, 0xcc, 0x9f,
	0xec, 0x51, 0x47, 0xb5, 0xe8, 0xd7, 0xa1, 0x31, 0xa7, 0xb1, 0xe5, 0x07, 0x52, 0x56, 0xcb, 0x5c,
	0x99, 0xd3, 0xf8, 0x55, 0x60, 0x9c, 0xcb, 0x61, 0x9f, 0x52, 0x3e, 0xe4, 0x36, 0xa7, 0xc6, 0xcf,
	0x75, 0x51, 0x34, 0x23, 0x55, 0x92, 0xa4, 0xd1, 0xf6, 0x3c, 0x98, 0xf1, 0xe4, 0xd8, 0xa0, 0x46,
	0x49, 0xd7, 0xa5, 0x9a, 0x75, 0x5d, 0x2e, 0x40, 0x63, 0x2a, 0x1b, 0x9d, 0x18, 0xf1, 0x38, 0x2a,
	0x34, 0x77, 0xea, 0x4b, 0x9a, 0x3b, 0x2b, 0xcb, 0x9a, 0x3b, 0x4b, 0x8f, 0xf6, 0x8d, 0x33, 0x8e,
	0xf6, 0x9b, 0x00, 0x11, 0x8d, 0x29, 0x97, 0xc7, 0x6e, 0xf9, 0x05, 0x69, 0x9b, 0x6d, 0x49, 0x11,
	0x67, 0x64, 0x91, 0x60, 0x14, 0x3b, 0x69, 0x40, 0xb4, 0x54, 0x82, 0x91, 0xc4, 0xa4, 0x35, 0x7a,
	0x17, 0xf4, 0x08, 0x9b, 0x10, 0xd6, 0x5b, 0x7b, 0xa2, 0x8e, 0xf0, 0x78, 0xe9, 0x42, 0x12, 0xce,
	0x13, 0x7b, 0x22, 0xcf, 0xf0, 0xfa, 0x1d, 0x58, 0x4b, 0xd1, 0xe9, 0xa1, 0x1a, 0x64, 0x94, 0xac,
	0x26, 0x8c, 0x37, 0x78, 0xb8, 0xbe, 0x05, 0x29, 0x29, 0x39, 0xe6, 0x77, 0xd4, 0xbe, 0x4f, 0xc8,
	0xaa, 0x5c, 0xd6, 0xbf, 0x86, 0xcb, 0x29, 0xd0, 0x9e, 0xf1, 0xc0, 0x72, 0x02, 0x51, 0xc2, 0x71,
	0xea, 0x2a, 0x65, 0x34, 0xf9, 0xd6, 0xc5, 0x04, 0xf3, 0x68, 0xc6, 0x83, 0xdd, 0x04, 0x91, 0x18,
	0xfa, 0x16, 0xc3, 0x4b, 0x45, 0x93, 0xba, 0xbe, 0xd1, 0x12, 0xa2, 0x0c, 0xa7, 0x6b, 0xa0, 0xc5,
	0x3c, 0x88, 0xec, 0x11, 0xcd, 0xdf, 0xdf, 0x74, 0x90, 0x26, 0x20, 0x22, 0x6e, 0x73, 0x51, 0x11,
	0x84, 0xc6, 0x01, 0x68, 0x29, 0xe1, 0x45, 0x30, 0x92, 0xfd, 0x0f, 0x7a, 0x4c, 0x3d, 0xdc, 0x31,
	0x6a, 0x20, 0x02, 0xe2, 0x68, 0xe6, 0x4c, 0x28, 0xc7, 0x28, 0xc1, 0x91, 0xd8, 0x1a, 0x9c, 0x9e,
	0x70, 0x0c, 0x13, 0xf9, 0x6c, 0xac, 0xc3, 0xb9, 0x54, 0xe2, 0x13, 0xe6, 0x79, 0xbb, 0x81, 0xff,
	0x96, 0x8d, 0xee, 0xfc, 0xf7, 0x39, 0xe8, 0xe0, 0x49, 0x4a, 0x7e, 0x47, 0xb7, 0xe0, 0x42, 0x6e,
	0x68, 0x65, 0xf7, 0x8b, 0xe4, 0xcf, 0x36, 0xea, 0xff, 0xf4, 0x9f, 0xfd, 0x8a, 0xbe, 0x91, 0x9e,
	0xa2, 0x25, 0xe2, 0x80, 0xf9, 0x23, 0x52, 0x41, 0xde, 0x26, 0x9c, 0xcb, 0xf3, 0xf0, 0x7a, 0x82,
	0x54, 0x37, 0xea, 0xff, 0x5c, 0xc2, 0xc6, 0x0b, 0x08, 0x52, 0x43, 0xf6, 0x55, 0x58, 0xcf, 0xb3,
	0xd3, 0xdb, 0x1a, 0x52, 0x47, 0xf1, 0x0b, 0xca, 0x65, 0xed, 0x4e, 0xb2, 0x82, 0x88, 0x6d, 0xb8,
	0x58, 0x98, 0x21, 0x9f, 0x0c, 0x48, 0x03, 0x41, 0xd7, 0x61, 0xa3, 0x0c, 0xa4, 0x12, 0x04, 0x69,
	0x96, 0x4f, 0x96, 0xf5, 0xfc, 0x49, 0xbb, 0xdc, 0xda, 0x84, 0x0d, 0x68, 0x8e, 0x01, 0xfd, 0x05,
	0x01, 0x69, 0xdb, 0x9d, 0x74, 0x50, 0xc4, 0x82, 0xc9, 0x19, 0x40, 0x43, 0x21, 0x0b, 0x5a, 0x64,
	0x2d, 0x5d, 0xd2, 0x45, 0x11, 0xd7, 0xe0, 0xa3, 0x3c, 0x22, 0xd7, 0x01, 0x25, 0x3d, 0x84, 0x5c,
	0x06, 0xbd, 0xb0, 0x2c, 0xb2, 0x42, 0x25, 0xab, 0xc8, 0x5d, 0xd0, 0x33, 0x7f, 0x8c, 0x21, 0x04,
	0x31, 0x57, 0xe0, 0x7c, 0xc1, 0x65, 0x78, 0xb1, 0x4c, 0xd6, 0x50, 0xcd, 0x9b, 0x70, 0x79, 0x21,
	0x28, 0x0a, 0x17, 0x36, 0x44, 0x2f, 0xf7, 0x49, 0xfe, 0xea, 0x86, 0x9c, 0x2b, 0xd7, 0x56, 0x5d,
	0xde, 0x90, 0xf3, 0xe5, 0x1e, 0x4b, 0xab, 0x2d, 0xb2, 0x8e, 0x53, 0x5c, 0x82, 0xb5, 0x22, 0x40,
	0xc8, 0xbe, 0x50, 0xbe, 0xf4, 0xc5, 0x1e, 0x00, 0xf9, 0xa8, 0xdc, 0x23, 0xf9, 0x0b, 0x4b, 0xd2,
	0x2f, 0x8f, 0xb4, 0xc2, 0x25, 0x26, 0xb9, 0x58, 0x0e, 0x2a, 0x5c, 0x92, 0x91, 0x8d, 0xf2, 0xb0,
	0x4f, 0xaf, 0xc6, 0xc8, 0xa5, 0xa5, 0x91, 0x88, 0xa5, 0x33, 0xd9, 0x2c, 0x8f, 0xc4, 0x84, 0x7d,
	0x05, 0x67, 0x58, 0xb0, 0xba, 0xd8, 0x36, 0x26, 0xdb, 0xe5, 0xa1, 0x96, 0xb5, 0x92, 0xc9, 0xf5,
	0xf2, 0x50, 0xcb, 0xb5, 0x10, 0xc9, 0xcd, 0x72, 0x8b, 0x0b, 0x8d, 0x3f, 0x72, 0x0b, 0x41, 0x0b,
	0xd1, 0xb2, 0xd8, 0x94, 0x23, 0x3b, 0xa8, 0xd1, 0x2d, 0xd8, 0x2c, 0x44, 0xcb, 0xe2, 0xe5, 0x1d,
	0xb9, 0x8d, 0xc0, 0x85, 0x59, 0x0b, 0x17, 0x7a, 0xe4, 0x4e, 0xf9, 0xda, 0x17, 0x1b, 0x21, 0xe4,
	0xe3, 0xf2, 0xe8, 0x43, 0xee, 0xdd, 0x72, 0x4f, 0x16, 0xbb, 0xe8, 0xe4, 0xcf, 0xcb, 0xfd, 0x94,
	0x6b, 0x23, 0x93, 0x41, 0x79, 0x2a, 0xc4, 0xd6, 0x32, 0xb9, 0x57, 0xee, 0xa1, 0xc5, 0xf6, 0x0e,
	0xf9, 0x64, 0xd9, 0xca, 0xe6, 0xfb, 0x71, 0xe4, 0xd3, 0x72, 0x69, 0x8b, 0xdd, 0x40, 0x72, 0xbf,
	0x5c, 0x5a, 0xb1, 0xbb, 0x47, 0x3e, 0x2b, 0x97, 0xb6, 0xd8, 0x90, 0x23, 0x9f, 0x97, 0xef, 0xf5,
	0xfc, 0xe1, 0x80, 0x3c, 0x28, 0x5f, 0x93, 0x62, 0x15, 0x4e, 0xbe, 0x40, 0x49, 0x0b, 0xfe, 0xcc,
	0xfd, 0xcd, 0x85, 0xfc, 0x05, 0x0a, 0xda, 0x81, 0x2b, 0x05, 0x13, 0x4f, 0xdd, 0xd8, 0x91, 0x2f,
	0x11, 0x79, 0x03, 0x2e, 0x95, 0x21, 0x13, 0xd8, 0x5f, 0x2e, 0xf1, 0x6c, 0xe1, 0x74, 0x4f, 0x1e,
	0xa2, 0xb0, 0x85, 0x08, 0x3d, 0x75, 0x06, 0x24, 0x7f, 0x55, 0x1e, 0xa1, 0x85, 0xa3, 0x15, 0xf9,
	0xeb, 0x25, 0xab, 0xbe, 0x70, 0xa1, 0x40, 0x0e, 0xca, 0x3d, 0x9b, 0xbf, 0x24, 0x20, 0x7f, 0x57,
	0x9e, 0xb1, 0x93, 0x7e, 0x06, 0x31, 0xcf, 0xc8, 0x5f, 0xc9, 0xb1, 0x84, 0x0c, 0xcb, 0x93, 0x6d,
	0x5a, 0xec, 0x93, 0xc3, 0xf2, 0xd4, 0x94, 0x9d, 0x24, 0xc8, 0x77, 0xe5, 0x1e, 0x3a, 0x75, 0x5e,
	0x20, 0xaf, 0xcb, 0xd3, 0x60, 0x5a, 0xf0, 0x93, 0x37, 0x67, 0x48, 0xca, 0x9f, 0x08, 0xc8, 0xf7,
	0xe5, 0x69, 0xe3, 0x54, 0xc5, 0x4e, 0xdc, 0x8d, 0xfa, 0xbf, 0x9c, 0x05, 0x4c, 0xca, 0x75, 0x42,
	0x11, 0x78, 0x6a, 0x63, 0xe4, 0x2b, 0x78, 0xf2, 0x76, 0xa3, 0xfe, 0x4b, 0x89, 0x4b, 0x0b, 0x15,
	0x1d, 0x19, 0xa1, 0xa8, 0x85, 0xb5, 0xcb, 0x57, 0x79, 0x64, 0x8c, 0x82, 0x6e, 0xc3, 0xd5, 0x52,
	0x4c, 0x56, 0xb7, 0x11, 0xa6, 0xa0, 0x8f, 0xef, 0xc2, 0x86, 0x13, 0x4c, 0x07, 0x13, 0x4a, 0xc3,
	0x09, 0x9d, 0x0f, 0xd4, 0x9f, 0xa4, 0xe4, 0xdf, 0xc3, 0x9c, 0xc0, 0x7b, 0xdc, 0x7b, 0x4e, 0x69,
	0xf8, 0x9c, 0x26, 0x09, 0xf8, 0x8f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x3a, 0x38, 0xc0, 0xf9, 0x4f,
	0x26, 0x00, 0x00,
}
