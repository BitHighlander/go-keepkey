package daemon

import (
	"context"
	"os"

	"log"

	"github.com/golang/protobuf/proto"
	keepkey "github.com/solipsis/go-keepkey/pkg/keepkey"
	"github.com/solipsis/go-keepkey/pkg/kkProto"
	pb "github.com/solipsis/go-keepkey/rpc/daemon"
)

// Server implements the daemon service
type Server struct {
	kk *keepkey.Keepkey // TODO: convert this to a map of kks
}

// TODO: replace me with middleware
func (s *Server) connect() error {
	kks, err := keepkey.GetDevicesWithConfig(&keepkey.KeepkeyConfig{AutoButton: false})
	if err != nil {
		log.Println(err)
		return err
	}
	s.kk = kks[0]
	s.kk.SetLogger(log.New(os.Stdout, "DEBUG: ", log.Ltime))

	return nil
}

func authResponses() []proto.Message {
	return []proto.Message{&kkProto.ButtonRequest{}, &kkProto.PinMatrixRequest{}, &kkProto.PassphraseRequest{}}
}

var cache proto.Message = nil

func (s *Server) Ping(ctx context.Context, req *pb.PingRequest) (resp *pb.PingResponse, err error) {

	// TODO: middleware handler to deal with initial connecting?
	if s.kk == nil {
		if err := s.connect(); err != nil {
			return nil, err
		}
	}

	if cache != nil {
		s, z := cache.(*kkProto.Success)
		if !z {
			log.Fatal(err)
		}

		cache = nil
		return &pb.PingResponse{Response: s.GetMessage()}, nil
	}

	success := &kkProto.Success{}
	expected := append(authResponses(), success)

	// Is this handling auth
	// if auth expect result or another auth
	// if auth we need to dectect what kind and add
	// to auth request object. How to do cleanly?
	// If expected and index < 3?
	// are there any methods that don't support all kinds of auth? yes?
	// maybe pass expected with num of auth messages?
	// but still can't descriminate type
	// maybe return type uint from kkeepkeyExchange
	/*
		if req.AuthResponse != nil {
			if _, err := s.kk.KeepkeyExchange(&kkProto.ButtonAck{}, expected...); err != nil {
				return nil, err
			}
			cache = success
			return &pb.PingResponse{AuthRequest: &pb.AuthRequest{ButtonRequest: &pb.ButtonRequest{}}}
			//return &pb.PingResponse{Response: success.GetMessage()}, nil
		}
	*/

	params := req.GetParams()
	ping := &kkProto.Ping{
		Message:              &params.Msg,
		ButtonProtection:     &params.Display,
		PinProtection:        &params.Pin,
		PassphraseProtection: &params.Passphrase,
	}
	success = new(kkProto.Success)
	expected = append(authResponses(), success)
	n, err := s.kk.KeepkeyExchange(ping, expected...)
	if err != nil {
		return nil, err
	}

	switch expected[n].(type) {
	case *kkProto.ButtonRequest:
		if _, err := s.kk.KeepkeyExchange(&kkProto.ButtonAck{}, expected...); err != nil {
			return nil, err
		}
		cache = success

		return &pb.PingResponse{AuthRequest: &pb.AuthRequest{Button: &pb.ButtonRequest{}}}, nil
	}

	return &pb.PingResponse{Response: success.GetMessage()}, nil
}

// CHANGE Messages to accept handler funcs for various setups.
// autogenerated clients probably don't want anything handled automatically
//

// standaard. Ping -> buttonReq <- autoButton ack -> success <-
// rpc Ping -> buttonReq (rpc forward back) <- button ack -> success (rpc pingResp) <-
